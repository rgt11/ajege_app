{"ast":null,"code":"import _objectSpread from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _inherits from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport _toConsumableArray from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _createForOfIteratorHelper from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"D:/mobilecross/Ajege/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport isEqual from 'fast-deep-equal/es6';\nimport React, { useRef, useState, useEffect, useContext } from 'react';\nimport produce$1, { enablePatches, produceWithPatches, produce, applyPatches } from 'immer';\n\nfunction useStoreState(store, getSubState, deps) {\n  var updateRef = useRef({\n    state: undefined,\n    initialized: false\n  });\n\n  if (!updateRef.current.initialized) {\n    updateRef.current.state = getSubState ? getSubState(store.getRawState()) : store.getRawState();\n    updateRef.current.initialized = true;\n  }\n\n  var _useState = useState(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      setUpdateTrigger = _useState2[1];\n\n  useEffect(function () {\n    var effectState = {\n      shouldUpdate: true\n    };\n\n    function update() {\n      if (effectState.shouldUpdate) {\n        var nextSubState = getSubState ? getSubState(store.getRawState()) : store.getRawState();\n\n        if (!isEqual(updateRef.current.state, nextSubState)) {\n          if (effectState.shouldUpdate) {\n            updateRef.current.state = nextSubState;\n            setUpdateTrigger(function (val) {\n              return val + 1;\n            });\n          }\n        }\n      }\n    }\n\n    store._addUpdateListener(update);\n\n    update();\n    return function () {\n      effectState.shouldUpdate = false;\n\n      store._removeUpdateListener(update);\n    };\n  }, deps !== null && deps !== void 0 ? deps : []);\n\n  if (deps !== undefined) {\n    var prevDeps = useRef(deps);\n\n    if (!isEqual(deps, prevDeps)) {\n      updateRef.current.state = getSubState(store.getRawState());\n    }\n  }\n\n  return updateRef.current.state;\n}\n\nvar updateListenerOrd = 0;\n\nfunction fastGet(obj, path) {\n  return path.reduce(function () {\n    var cur = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : obj;\n    var key = arguments.length > 1 ? arguments[1] : undefined;\n    return cur[key];\n  }, undefined);\n}\n\nfunction getSubStateFromPaths(store, paths) {\n  var state = store.getRawState();\n  var resp = [];\n\n  var _iterator = _createForOfIteratorHelper(paths),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var path = _step.value;\n      resp.push(fastGet(state, path));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return resp;\n}\n\nfunction useStoreStateOpt(store, paths) {\n  var _useState3 = useState(function () {\n    return getSubStateFromPaths(store, paths);\n  }),\n      _useState4 = _slicedToArray(_useState3, 2),\n      subState = _useState4[0],\n      setSubState = _useState4[1];\n\n  var updateRef = useRef({\n    shouldUpdate: true,\n    onStoreUpdate: null,\n    currentSubState: null,\n    ordKey: \"_\".concat(updateListenerOrd++)\n  });\n  updateRef.current.currentSubState = subState;\n\n  if (updateRef.current.onStoreUpdate === null) {\n    updateRef.current.onStoreUpdate = function onStoreUpdateOpt() {\n      if (updateRef.current.shouldUpdate) {\n        setSubState(getSubStateFromPaths(store, paths));\n      }\n    };\n\n    store._addUpdateListenerOpt(updateRef.current.onStoreUpdate, updateRef.current.ordKey, paths);\n  }\n\n  useEffect(function () {\n    return function () {\n      updateRef.current.shouldUpdate = false;\n\n      store._removeUpdateListenerOpt(updateRef.current.ordKey);\n    };\n  }, []);\n  return subState;\n}\n\nfunction useLocalStore(initialState, deps) {\n  var storeRef = useRef();\n\n  if (storeRef.current == null) {\n    storeRef.current = new Store(initialState);\n  }\n\n  if (deps !== undefined) {\n    var prevDeps = useRef(deps);\n\n    if (!isEqual(deps, prevDeps)) {\n      storeRef.current = new Store(initialState);\n    }\n  }\n\n  return storeRef.current;\n}\n\nvar globalClientState = {\n  storeOrdinal: 0,\n  batching: false,\n  flushStores: {}\n};\nenablePatches();\n\nfunction makeSubscriptionFunction(store, watch, listener) {\n  var lastWatchState = watch(store.getRawState());\n  return function () {\n    var currentState = store.getRawState();\n    var nextWatchState = watch(currentState);\n\n    if (!isEqual(nextWatchState, lastWatchState)) {\n      listener(nextWatchState, currentState, lastWatchState);\n      lastWatchState = nextWatchState;\n    }\n  };\n}\n\nfunction makeReactionFunctionCreator(watch, reaction) {\n  return function (store) {\n    var lastWatchState = watch(store.getRawState());\n    return function () {\n      var forceRun = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var currentState = store.getRawState();\n      var nextWatchState = watch(currentState);\n\n      if (forceRun || !isEqual(nextWatchState, lastWatchState)) {\n        if (store._optListenerCount > 0) {\n          var _produceWithPatches = produceWithPatches(currentState, function (s) {\n            return reaction(nextWatchState, s, currentState, lastWatchState);\n          }),\n              _produceWithPatches2 = _slicedToArray(_produceWithPatches, 3),\n              nextState = _produceWithPatches2[0],\n              patches = _produceWithPatches2[1],\n              inversePatches = _produceWithPatches2[2];\n\n          store._updateStateWithoutReaction(nextState);\n\n          lastWatchState = nextWatchState;\n\n          if (patches.length > 0) {\n            store._patchListeners.forEach(function (listener) {\n              return listener(patches, inversePatches);\n            });\n\n            return Object.keys(getChangedPathsFromPatches(patches));\n          }\n        } else {\n          if (store._patchListeners.length > 0) {\n            var _produceWithPatches3 = produceWithPatches(currentState, function (s) {\n              return reaction(nextWatchState, s, currentState, lastWatchState);\n            }),\n                _produceWithPatches4 = _slicedToArray(_produceWithPatches3, 3),\n                _nextState = _produceWithPatches4[0],\n                _patches = _produceWithPatches4[1],\n                _inversePatches = _produceWithPatches4[2];\n\n            if (_patches.length > 0) {\n              store._patchListeners.forEach(function (listener) {\n                return listener(_patches, _inversePatches);\n              });\n            }\n\n            store._updateStateWithoutReaction(_nextState);\n          } else {\n            store._updateStateWithoutReaction(produce(currentState, function (s) {\n              return reaction(nextWatchState, s, currentState, lastWatchState);\n            }));\n          }\n\n          lastWatchState = nextWatchState;\n        }\n      }\n\n      return [];\n    };\n  };\n}\n\nvar optPathDivider = \"~._.~\";\n\nvar Store = /*#__PURE__*/function () {\n  function Store(initialState) {\n    _classCallCheck(this, Store);\n\n    this.updateListeners = [];\n    this.ssr = false;\n    this.reactions = [];\n    this.clientSubscriptions = [];\n    this.reactionCreators = [];\n    this.optimizedUpdateListeners = {};\n    this.optimizedUpdateListenerPaths = {};\n    this.optimizedListenerPropertyMap = {};\n    this._optListenerCount = 0;\n    this._patchListeners = [];\n\n    if (initialState instanceof Function) {\n      var state = initialState();\n      this.currentState = state;\n      this.initialState = state;\n      this.createInitialState = initialState;\n    } else {\n      this.currentState = initialState;\n      this.initialState = initialState;\n\n      this.createInitialState = function () {\n        return initialState;\n      };\n    }\n\n    this.internalOrdId = globalClientState.storeOrdinal++;\n  }\n\n  _createClass(Store, [{\n    key: \"_setInternalOptions\",\n    value: function _setInternalOptions(_ref) {\n      var _this = this;\n\n      var ssr = _ref.ssr,\n          _ref$reactionCreators = _ref.reactionCreators,\n          reactionCreators = _ref$reactionCreators === void 0 ? [] : _ref$reactionCreators;\n      this.ssr = ssr;\n      this.reactionCreators = reactionCreators;\n      this.reactions = reactionCreators.map(function (rc) {\n        return rc(_this);\n      });\n    }\n  }, {\n    key: \"_getReactionCreators\",\n    value: function _getReactionCreators() {\n      return this.reactionCreators;\n    }\n  }, {\n    key: \"_instantiateReactions\",\n    value: function _instantiateReactions() {\n      var _this2 = this;\n\n      this.reactions = this.reactionCreators.map(function (rc) {\n        return rc(_this2);\n      });\n    }\n  }, {\n    key: \"_getInitialState\",\n    value: function _getInitialState() {\n      return this.createInitialState();\n    }\n  }, {\n    key: \"_updateStateWithoutReaction\",\n    value: function _updateStateWithoutReaction(nextState) {\n      this.currentState = nextState;\n    }\n  }, {\n    key: \"_updateState\",\n    value: function _updateState(nextState) {\n      var updateKeyedPaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      this.currentState = nextState;\n      this.batchState = undefined;\n\n      var _iterator2 = _createForOfIteratorHelper(this.reactions),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var runReaction = _step2.value;\n          updateKeyedPaths.push.apply(updateKeyedPaths, _toConsumableArray(runReaction()));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (!this.ssr) {\n        var _iterator3 = _createForOfIteratorHelper(this.clientSubscriptions),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var runSubscription = _step3.value;\n            runSubscription();\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        if (updateKeyedPaths.length > 0) {\n          var updateOrds = new Set();\n\n          var _iterator4 = _createForOfIteratorHelper(updateKeyedPaths),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var keyedPath = _step4.value;\n\n              if (this.optimizedListenerPropertyMap[keyedPath]) {\n                var _iterator6 = _createForOfIteratorHelper(this.optimizedListenerPropertyMap[keyedPath]),\n                    _step6;\n\n                try {\n                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                    var ord = _step6.value;\n                    updateOrds.add(ord);\n                  }\n                } catch (err) {\n                  _iterator6.e(err);\n                } finally {\n                  _iterator6.f();\n                }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          var _iterator5 = _createForOfIteratorHelper(updateOrds.values()),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _ord = _step5.value;\n\n              if (this.optimizedUpdateListeners[_ord]) {\n                this.optimizedUpdateListeners[_ord]();\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n\n        this.updateListeners.forEach(function (listener) {\n          return listener();\n        });\n      }\n    }\n  }, {\n    key: \"_addUpdateListener\",\n    value: function _addUpdateListener(listener) {\n      this.updateListeners.push(listener);\n    }\n  }, {\n    key: \"_addUpdateListenerOpt\",\n    value: function _addUpdateListenerOpt(listener, ordKey, paths) {\n      this.optimizedUpdateListeners[ordKey] = listener;\n      var listenerPathsKeyed = paths.map(function (path) {\n        return path.join(optPathDivider);\n      });\n      this.optimizedUpdateListenerPaths[ordKey] = listenerPathsKeyed;\n\n      var _iterator7 = _createForOfIteratorHelper(listenerPathsKeyed),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var keyedPath = _step7.value;\n\n          if (this.optimizedListenerPropertyMap[keyedPath] == null) {\n            this.optimizedListenerPropertyMap[keyedPath] = [ordKey];\n          } else {\n            this.optimizedListenerPropertyMap[keyedPath].push(ordKey);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      this._optListenerCount++;\n    }\n  }, {\n    key: \"_removeUpdateListener\",\n    value: function _removeUpdateListener(listener) {\n      this.updateListeners = this.updateListeners.filter(function (f) {\n        return f !== listener;\n      });\n    }\n  }, {\n    key: \"_removeUpdateListenerOpt\",\n    value: function _removeUpdateListenerOpt(ordKey) {\n      var listenerPathsKeyed = this.optimizedUpdateListenerPaths[ordKey];\n\n      var _iterator8 = _createForOfIteratorHelper(listenerPathsKeyed),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var keyedPath = _step8.value;\n          this.optimizedListenerPropertyMap[keyedPath] = this.optimizedListenerPropertyMap[keyedPath].filter(function (ord) {\n            return ord !== ordKey;\n          });\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      delete this.optimizedUpdateListenerPaths[ordKey];\n      delete this.optimizedUpdateListeners[ordKey];\n      this._optListenerCount--;\n    }\n  }, {\n    key: \"listenToPatches\",\n    value: function listenToPatches(patchListener) {\n      var _this3 = this;\n\n      this._patchListeners.push(patchListener);\n\n      return function () {\n        _this3._patchListeners = _this3._patchListeners.filter(function (f) {\n          return f !== patchListener;\n        });\n      };\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(watch, listener) {\n      var _this4 = this;\n\n      if (!this.ssr) {\n        var func = makeSubscriptionFunction(this, watch, listener);\n        this.clientSubscriptions.push(func);\n        return function () {\n          _this4.clientSubscriptions = _this4.clientSubscriptions.filter(function (f) {\n            return f !== func;\n          });\n        };\n      }\n\n      return function () {\n        console.warn(\"Pullstate: Subscriptions made on the server side are not registered - so therefor this call to unsubscribe does nothing.\");\n      };\n    }\n  }, {\n    key: \"createReaction\",\n    value: function createReaction(watch, reaction) {\n      var _this5 = this;\n\n      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref2$runNow = _ref2.runNow,\n          runNow = _ref2$runNow === void 0 ? false : _ref2$runNow,\n          _ref2$runNowWithSideE = _ref2.runNowWithSideEffects,\n          runNowWithSideEffects = _ref2$runNowWithSideE === void 0 ? false : _ref2$runNowWithSideE;\n\n      var creator = makeReactionFunctionCreator(watch, reaction);\n      this.reactionCreators.push(creator);\n      var func = creator(this);\n      this.reactions.push(func);\n\n      if (runNow || runNowWithSideEffects) {\n        func(true);\n\n        if (runNowWithSideEffects && !this.ssr) {\n          this._updateState(this.currentState);\n        }\n      }\n\n      return function () {\n        _this5.reactions = _this5.reactions.filter(function (f) {\n          return f !== func;\n        });\n      };\n    }\n  }, {\n    key: \"getRawState\",\n    value: function getRawState() {\n      if (this.batchState !== undefined) {\n        return this.batchState;\n      } else {\n        return this.currentState;\n      }\n    }\n  }, {\n    key: \"useState\",\n    value: function useState(getSubState, deps) {\n      return useStoreState(this, getSubState, deps);\n    }\n  }, {\n    key: \"useLocalCopyInitial\",\n    value: function useLocalCopyInitial(deps) {\n      return useLocalStore(this.createInitialState, deps);\n    }\n  }, {\n    key: \"useLocalCopySnapshot\",\n    value: function useLocalCopySnapshot(deps) {\n      return useLocalStore(this.currentState, deps);\n    }\n  }, {\n    key: \"flushBatch\",\n    value: function flushBatch() {\n      var ignoreError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.batchState !== undefined) {\n        if (this.batchState !== this.currentState) {\n          this._updateState(this.batchState);\n        }\n      } else if (!ignoreError) {\n        console.error(\"Pullstate: Trying to flush batch state which was never created or updated on\");\n      }\n\n      this.batchState = undefined;\n    }\n  }, {\n    key: \"update\",\n    value: function update(updater, patchesCallback) {\n      if (globalClientState.batching) {\n        if (this.batchState === undefined) {\n          this.batchState = this.currentState;\n          globalClientState.flushStores[this.internalOrdId] = this;\n        }\n\n        var func = typeof updater === \"function\";\n\n        var _runUpdates = runUpdates(this.batchState, updater, func),\n            _runUpdates2 = _slicedToArray(_runUpdates, 3),\n            nextState = _runUpdates2[0],\n            patches = _runUpdates2[1],\n            inversePatches = _runUpdates2[2];\n\n        if (patches.length > 0 && (this._patchListeners.length > 0 || patchesCallback)) {\n          if (patchesCallback) {\n            patchesCallback(patches, inversePatches);\n          }\n\n          this._patchListeners.forEach(function (listener) {\n            return listener(patches, inversePatches);\n          });\n        }\n\n        this.batchState = nextState;\n      } else {\n        this.batchState = undefined;\n\n        _update(this, updater, patchesCallback);\n      }\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(newState) {\n      this._updateState(newState);\n    }\n  }, {\n    key: \"applyPatches\",\n    value: function applyPatches(patches) {\n      applyPatchesToStore(this, patches);\n    }\n  }]);\n\n  return Store;\n}();\n\nfunction applyPatchesToStore(store, patches) {\n  var currentState = store.getRawState();\n  var nextState = applyPatches(currentState, patches);\n\n  if (nextState !== currentState) {\n    store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\n  }\n}\n\nfunction getChangedPathsFromPatches(changePatches) {\n  var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _iterator9 = _createForOfIteratorHelper(changePatches),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var patch = _step9.value;\n      var curKey = void 0;\n\n      var _iterator10 = _createForOfIteratorHelper(patch.path),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var p = _step10.value;\n\n          if (curKey) {\n            curKey = \"\".concat(curKey).concat(optPathDivider).concat(p);\n          } else {\n            curKey = p;\n          }\n\n          prev[curKey] = 1;\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  return prev;\n}\n\nfunction runUpdates(currentState, updater, func) {\n  return func ? produceWithPatches(currentState, function (s) {\n    return updater(s, currentState);\n  }) : updater.reduce(function (_ref3, currentValue) {\n    var _ref4 = _slicedToArray(_ref3, 3),\n        nextState = _ref4[0],\n        patches = _ref4[1],\n        inversePatches = _ref4[2];\n\n    var resp = produceWithPatches(nextState, function (s) {\n      return currentValue(s, nextState);\n    });\n    patches.push.apply(patches, _toConsumableArray(resp[1]));\n    inversePatches.push.apply(inversePatches, _toConsumableArray(resp[2]));\n    return [resp[0], patches, inversePatches];\n  }, [currentState, [], []]);\n}\n\nfunction _update(store, updater, patchesCallback) {\n  var currentState = store.getRawState();\n  var func = typeof updater === \"function\";\n\n  if (store._optListenerCount > 0) {\n    var _runUpdates3 = runUpdates(currentState, updater, func),\n        _runUpdates4 = _slicedToArray(_runUpdates3, 3),\n        nextState = _runUpdates4[0],\n        patches = _runUpdates4[1],\n        inversePatches = _runUpdates4[2];\n\n    if (patches.length > 0) {\n      if (patchesCallback) {\n        patchesCallback(patches, inversePatches);\n      }\n\n      store._patchListeners.forEach(function (listener) {\n        return listener(patches, inversePatches);\n      });\n\n      store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\n    }\n  } else {\n    var _nextState2;\n\n    if (store._patchListeners.length > 0 || patchesCallback) {\n      var _runUpdates5 = runUpdates(currentState, updater, func),\n          _runUpdates6 = _slicedToArray(_runUpdates5, 3),\n          ns = _runUpdates6[0],\n          _patches2 = _runUpdates6[1],\n          _inversePatches2 = _runUpdates6[2];\n\n      if (_patches2.length > 0) {\n        if (patchesCallback) {\n          patchesCallback(_patches2, _inversePatches2);\n        }\n\n        store._patchListeners.forEach(function (listener) {\n          return listener(_patches2, _inversePatches2);\n        });\n      }\n\n      _nextState2 = ns;\n    } else {\n      _nextState2 = produce(currentState, function (s) {\n        return func ? updater(s, currentState) : updater.reduce(function (previousValue, currentUpdater) {\n          return produce(previousValue, function (s) {\n            return currentUpdater(s, previousValue);\n          });\n        }, currentState);\n      });\n    }\n\n    if (_nextState2 !== currentState) {\n      store._updateState(_nextState2);\n    }\n  }\n}\n\nfunction InjectStoreState(_ref5) {\n  var store = _ref5.store,\n      _ref5$on = _ref5.on,\n      on = _ref5$on === void 0 ? function (s) {\n    return s;\n  } : _ref5$on,\n      children = _ref5.children;\n  var state = useStoreState(store, on);\n  return children(state);\n}\n\nvar EAsyncEndTags;\n\n(function (EAsyncEndTags) {\n  EAsyncEndTags[\"THREW_ERROR\"] = \"THREW_ERROR\";\n  EAsyncEndTags[\"RETURNED_ERROR\"] = \"RETURNED_ERROR\";\n  EAsyncEndTags[\"UNFINISHED\"] = \"UNFINISHED\";\n  EAsyncEndTags[\"DORMANT\"] = \"DORMANT\";\n})(EAsyncEndTags || (EAsyncEndTags = {}));\n\nvar EPostActionContext;\n\n(function (EPostActionContext) {\n  EPostActionContext[\"WATCH_HIT_CACHE\"] = \"WATCH_HIT_CACHE\";\n  EPostActionContext[\"BECKON_HIT_CACHE\"] = \"BECKON_HIT_CACHE\";\n  EPostActionContext[\"RUN_HIT_CACHE\"] = \"RUN_HIT_CACHE\";\n  EPostActionContext[\"READ_HIT_CACHE\"] = \"READ_HIT_CACHE\";\n  EPostActionContext[\"READ_RUN\"] = \"READ_RUN\";\n  EPostActionContext[\"SHORT_CIRCUIT\"] = \"SHORT_CIRCUIT\";\n  EPostActionContext[\"DIRECT_RUN\"] = \"DIRECT_RUN\";\n  EPostActionContext[\"BECKON_RUN\"] = \"BECKON_RUN\";\n  EPostActionContext[\"CACHE_UPDATE\"] = \"CACHE_UPDATE\";\n})(EPostActionContext || (EPostActionContext = {}));\n\nvar clientAsyncCache = {\n  listeners: {},\n  results: {},\n  actions: {},\n  actionOrd: {}\n};\nvar asyncCreationOrdinal = 0;\n\nfunction keyFromObject(json) {\n  if (json === null) {\n    return \"(n)\";\n  }\n\n  var typeOf = typeof json;\n\n  if (typeOf !== \"object\") {\n    if (typeOf === \"undefined\") {\n      return \"(u)\";\n    } else if (typeOf === \"string\") {\n      return \":\" + json + \";\";\n    } else if (typeOf === \"boolean\" || typeOf === \"number\") {\n      return \"(\" + json + \")\";\n    }\n  }\n\n  var prefix = \"{\";\n\n  var _iterator11 = _createForOfIteratorHelper(Object.keys(json).sort()),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var key = _step11.value;\n      prefix += key + keyFromObject(json[key]);\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  return prefix + \"}\";\n}\n\nfunction notifyListeners(key) {\n  if (clientAsyncCache.listeners.hasOwnProperty(key)) {\n    for (var _i = 0, _Object$keys = Object.keys(clientAsyncCache.listeners[key]); _i < _Object$keys.length; _i++) {\n      var watchId = _Object$keys[_i];\n      clientAsyncCache.listeners[key][watchId]();\n    }\n  }\n}\n\nfunction clearActionCache(key) {\n  var clearPending = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var notify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (clearPending && clientAsyncCache.actionOrd.hasOwnProperty(key)) {\n    clientAsyncCache.actionOrd[key] += 1;\n  }\n\n  delete clientAsyncCache.results[key];\n\n  if (notify) {\n    notifyListeners(key);\n  }\n}\n\nfunction actionOrdUpdate(cache, key) {\n  if (!cache.actionOrd.hasOwnProperty(key)) {\n    cache.actionOrd[key] = 0;\n  } else {\n    cache.actionOrd[key] += 1;\n  }\n\n  return cache.actionOrd[key];\n}\n\nfunction successResult() {\n  var payload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  return {\n    payload: payload,\n    tags: tags,\n    message: message,\n    error: false,\n    errorPayload: null\n  };\n}\n\nfunction errorResult() {\n  var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var errorPayload = arguments.length > 2 ? arguments[2] : undefined;\n  return {\n    payload: null,\n    tags: [EAsyncEndTags.RETURNED_ERROR].concat(_toConsumableArray(tags)),\n    message: message,\n    error: true,\n    errorPayload: errorPayload\n  };\n}\n\nvar PullstateAsyncError = /*#__PURE__*/function (_Error) {\n  _inherits(PullstateAsyncError, _Error);\n\n  var _super = _createSuper(PullstateAsyncError);\n\n  function PullstateAsyncError(message, tags) {\n    var _this6;\n\n    _classCallCheck(this, PullstateAsyncError);\n\n    _this6 = _super.call(this, message);\n    _this6.tags = tags;\n    return _this6;\n  }\n\n  return PullstateAsyncError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar storeErrorProxy;\n\ntry {\n  storeErrorProxy = new Proxy({}, {\n    get: function get(obj, prop) {\n      throw new Error(\"Pullstate: Trying to access store (\".concat(String(prop), \") inside async actions without the correct usage or setup.\\nIf this error occurred on the server:\\n* If using run(), make use of your created instance for this request: instance.runAsyncAction()\\n* If using read(), useWatch(), useBeckon() etc. - make sure you have properly set up your <PullstateProvider/>\\n\\nIf this error occurred on the client:\\n* Make sure you have created your \\\"pullstateCore\\\" object with all your stores, using createPullstateCore(), and are making use of instantiate() before rendering.\"));\n    }\n  });\n} catch (_unused) {\n  storeErrorProxy = {};\n}\n\nvar startedButUnfinishedResult = [true, false, {\n  message: \"\",\n  tags: [EAsyncEndTags.UNFINISHED],\n  error: true,\n  payload: null,\n  errorPayload: null\n}, false, -1];\n\nfunction _createAsyncActionDirect(action) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _createAsyncAction( /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(args, stores, customContext) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.t0 = successResult;\n              _context.next = 3;\n              return action(args, stores, customContext);\n\n            case 3:\n              _context.t1 = _context.sent;\n              return _context.abrupt(\"return\", (0, _context.t0)(_context.t1));\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2, _x3) {\n      return _ref6.apply(this, arguments);\n    };\n  }(), options);\n}\n\nfunction _createAsyncAction(action) {\n  var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref7$forceContext = _ref7.forceContext,\n      forceContext = _ref7$forceContext === void 0 ? false : _ref7$forceContext,\n      shortCircuitHook = _ref7.shortCircuitHook,\n      cacheBreakHook = _ref7.cacheBreakHook,\n      postActionHook = _ref7.postActionHook,\n      subsetKey = _ref7.subsetKey,\n      actionId = _ref7.actionId;\n\n  var ordinal = actionId != null ? \"_\".concat(actionId) : asyncCreationOrdinal++;\n  var onServer = typeof window === \"undefined\";\n\n  function _createKey(args, customKey) {\n    if (customKey != null) {\n      return \"\".concat(ordinal, \"-c-\").concat(customKey);\n    }\n\n    if (subsetKey !== undefined) {\n      return \"\".concat(ordinal, \"-\").concat(keyFromObject(subsetKey(args)));\n    }\n\n    return \"\".concat(ordinal, \"-\").concat(keyFromObject(args));\n  }\n\n  var deferWaitingKey = \"def_wait_\".concat(_createKey({}));\n  var cacheBreakWatcher = {};\n  var watchIdOrd = 0;\n  var shouldUpdate = {};\n\n  function runPostActionHook(result, args, stores, context) {\n    if (postActionHook !== undefined) {\n      postActionHook({\n        args: args,\n        result: result,\n        stores: stores,\n        context: context\n      });\n    }\n  }\n\n  function getCachedResult(_ref8) {\n    var args = _ref8.args,\n        cache = _ref8.cache,\n        cacheBreakEnabled = _ref8.cacheBreakEnabled,\n        context = _ref8.context,\n        fromListener = _ref8.fromListener,\n        key = _ref8.key,\n        postActionEnabled = _ref8.postActionEnabled,\n        stores = _ref8.stores,\n        customCacheBreak = _ref8.customCacheBreak;\n    var useCacheBreakHook = customCacheBreak !== null && customCacheBreak !== void 0 ? customCacheBreak : cacheBreakHook;\n\n    if (cache.results.hasOwnProperty(key)) {\n      var cacheBreakLoop = cacheBreakWatcher.hasOwnProperty(key) && cacheBreakWatcher[key] > 2;\n\n      if (!onServer && !fromListener && cacheBreakEnabled && useCacheBreakHook != null && cache.results[key][1] && useCacheBreakHook({\n        args: args,\n        result: cache.results[key][2],\n        stores: stores,\n        timeCached: cache.results[key][4]\n      }) && !cacheBreakLoop) {\n        if (cacheBreakWatcher.hasOwnProperty(key)) {\n          cacheBreakWatcher[key]++;\n        } else {\n          cacheBreakWatcher[key] = 1;\n        }\n\n        var previous = cache.results[key];\n        delete cache.results[key];\n        return {\n          cacheBroke: true,\n          response: undefined,\n          previous: previous\n        };\n      } else {\n        if (cacheBreakLoop) {\n          console.error(\"[\".concat(key, \"] Pullstate detected an infinite loop caused by cacheBreakHook()\\nreturning true too often (breaking cache as soon as your action is resolving - hence\\ncausing beckoned actions to run the action again) in one of your AsyncActions - Pullstate prevented\\nfurther looping. Fix in your cacheBreakHook() is needed.\"));\n        } else {\n          cacheBreakWatcher[key] = 0;\n        }\n\n        if (postActionEnabled && cache.results[key][1] && !fromListener) {\n          runPostActionHook(cache.results[key][2], args, stores, context);\n        }\n\n        return {\n          response: cache.results[key],\n          cacheBroke: false,\n          previous: undefined\n        };\n      }\n    }\n\n    return {\n      cacheBroke: false,\n      response: undefined,\n      previous: undefined\n    };\n  }\n\n  function createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, executionContext, customContext) {\n    return function () {\n      return action(args, stores, customContext).then(function (resp) {\n        if (currentActionOrd === cache.actionOrd[key]) {\n          if (postActionEnabled) {\n            runPostActionHook(resp, args, stores, executionContext);\n          }\n\n          cache.results[key] = [true, true, resp, false, Date.now()];\n        }\n\n        return resp;\n      }).catch(function (e) {\n        console.error(e);\n        var result = {\n          payload: null,\n          errorPayload: null,\n          error: true,\n          tags: [EAsyncEndTags.THREW_ERROR],\n          message: e.message\n        };\n\n        if (currentActionOrd === cache.actionOrd[key]) {\n          if (postActionEnabled) {\n            runPostActionHook(result, args, stores, executionContext);\n          }\n\n          cache.results[key] = [true, true, result, false, Date.now()];\n        }\n\n        return result;\n      }).then(function (resp) {\n        if (currentActionOrd === cache.actionOrd[key]) {\n          delete cache.actions[key];\n\n          if (!onServer) {\n            notifyListeners(key);\n          }\n        }\n\n        return resp;\n      });\n    };\n  }\n\n  function checkKeyAndReturnResponse(_ref9) {\n    var key = _ref9.key,\n        cache = _ref9.cache,\n        initiate = _ref9.initiate,\n        ssr = _ref9.ssr,\n        args = _ref9.args,\n        stores = _ref9.stores,\n        _ref9$fromListener = _ref9.fromListener,\n        fromListener = _ref9$fromListener === void 0 ? false : _ref9$fromListener,\n        _ref9$postActionEnabl = _ref9.postActionEnabled,\n        postActionEnabled = _ref9$postActionEnabl === void 0 ? true : _ref9$postActionEnabl,\n        _ref9$cacheBreakEnabl = _ref9.cacheBreakEnabled,\n        cacheBreakEnabled = _ref9$cacheBreakEnabl === void 0 ? true : _ref9$cacheBreakEnabl,\n        holdingResult = _ref9.holdingResult,\n        customContext = _ref9.customContext,\n        customCacheBreak = _ref9.customCacheBreak,\n        holdPrevious = _ref9.holdPrevious;\n    var cached = getCachedResult({\n      key: key,\n      cache: cache,\n      args: args,\n      stores: stores,\n      context: initiate ? EPostActionContext.BECKON_HIT_CACHE : EPostActionContext.WATCH_HIT_CACHE,\n      postActionEnabled: postActionEnabled,\n      cacheBreakEnabled: cacheBreakEnabled,\n      fromListener: fromListener,\n      customCacheBreak: customCacheBreak\n    });\n\n    if (cached.response) {\n      return cached.response;\n    }\n\n    if (!cache.actions.hasOwnProperty(key)) {\n      var currentActionOrd = actionOrdUpdate(cache, key);\n\n      if (initiate) {\n        if (shortCircuitHook !== undefined) {\n          var shortCircuitResponse = shortCircuitHook({\n            args: args,\n            stores: stores\n          });\n\n          if (shortCircuitResponse !== false) {\n            runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\n            cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\n            return cache.results[key];\n          }\n        }\n\n        if (ssr || !onServer) {\n          cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.BECKON_RUN, customContext);\n        }\n\n        if (!onServer) {\n          cache.actions[key]();\n          cache.results[key] = startedButUnfinishedResult;\n        } else {\n          return startedButUnfinishedResult;\n        }\n      } else {\n        var resp = [false, false, {\n          message: \"\",\n          tags: [EAsyncEndTags.UNFINISHED],\n          error: true,\n          payload: null,\n          errorPayload: null\n        }, false, -1];\n\n        if (!onServer) {\n          cache.results[key] = resp;\n        }\n\n        if (holdPrevious) {\n          if (holdingResult) {\n            var response = _toConsumableArray(holdingResult);\n\n            response[3] = true;\n            return response;\n          }\n\n          if (cached.previous != null) {\n            var _response = _toConsumableArray(cached.previous);\n\n            _response[3] = true;\n            return _response;\n          }\n        }\n\n        return resp;\n      }\n    }\n\n    if (holdPrevious) {\n      if (holdingResult) {\n        var _response2 = _toConsumableArray(holdingResult);\n\n        _response2[3] = true;\n        return _response2;\n      }\n\n      if (cached.previous != null) {\n        var _response3 = _toConsumableArray(cached.previous);\n\n        _response3[3] = true;\n        return _response3;\n      }\n    }\n\n    return startedButUnfinishedResult;\n  }\n\n  var read = function read() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref10$cacheBreakEnab = _ref10.cacheBreakEnabled,\n        cacheBreakEnabled = _ref10$cacheBreakEnab === void 0 ? true : _ref10$cacheBreakEnab,\n        _ref10$postActionEnab = _ref10.postActionEnabled,\n        postActionEnabled = _ref10$postActionEnab === void 0 ? true : _ref10$postActionEnab,\n        customKey = _ref10.key;\n\n    var key = _createKey(args, customKey);\n\n    var cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n    var stores;\n    var customContext;\n\n    if (onServer || forceContext) {\n      var pullstateContext = useContext(PullstateContext);\n      stores = pullstateContext.stores;\n      customContext = pullstateContext.customContext;\n    } else if (clientStores.loaded) {\n      stores = clientStores.stores;\n    } else {\n      stores = storeErrorProxy;\n    }\n\n    var cached = getCachedResult({\n      key: key,\n      cache: cache,\n      args: args,\n      stores: stores,\n      context: EPostActionContext.READ_HIT_CACHE,\n      postActionEnabled: postActionEnabled,\n      cacheBreakEnabled: cacheBreakEnabled,\n      fromListener: false\n    });\n\n    if (cached.response) {\n      if (!cached.response[2].error) {\n        return cached.response[2].payload;\n      } else {\n        throw new PullstateAsyncError(cached.response[2].message, cached.response[2].tags);\n      }\n    }\n\n    if (!cache.actions.hasOwnProperty(key)) {\n      if (shortCircuitHook !== undefined) {\n        var shortCircuitResponse = shortCircuitHook({\n          args: args,\n          stores: stores\n        });\n\n        if (shortCircuitResponse !== false) {\n          runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\n          cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\n\n          if (!shortCircuitResponse.error) {\n            return shortCircuitResponse.payload;\n          } else {\n            throw new PullstateAsyncError(shortCircuitResponse.message, shortCircuitResponse.tags);\n          }\n        }\n      }\n\n      var currentActionOrd = actionOrdUpdate(cache, key);\n      cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.READ_RUN, customContext);\n\n      if (onServer) {\n        throw new Error(\"Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )\");\n      }\n\n      throw cache.actions[key]();\n    }\n\n    if (onServer) {\n      throw new Error(\"Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )\");\n    }\n\n    var watchOrd = watchIdOrd++;\n    throw new Promise(function (resolve) {\n      cache.listeners[key][watchOrd] = function () {\n        delete cache.listeners[key][watchOrd];\n        resolve();\n      };\n    });\n  };\n\n  var useWatch = function useWatch() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref11$initiate = _ref11.initiate,\n        initiate = _ref11$initiate === void 0 ? false : _ref11$initiate,\n        _ref11$ssr = _ref11.ssr,\n        ssr = _ref11$ssr === void 0 ? true : _ref11$ssr,\n        _ref11$postActionEnab = _ref11.postActionEnabled,\n        postActionEnabled = _ref11$postActionEnab === void 0 ? false : _ref11$postActionEnab,\n        _ref11$cacheBreakEnab = _ref11.cacheBreakEnabled,\n        cacheBreakEnabled = _ref11$cacheBreakEnab === void 0 ? false : _ref11$cacheBreakEnab,\n        _ref11$holdPrevious = _ref11.holdPrevious,\n        holdPrevious = _ref11$holdPrevious === void 0 ? false : _ref11$holdPrevious,\n        _ref11$dormant = _ref11.dormant,\n        dormant = _ref11$dormant === void 0 ? false : _ref11$dormant,\n        customKey = _ref11.key,\n        customCacheBreak = _ref11.cacheBreak;\n\n    var responseRef = useRef();\n    var prevKeyRef = useRef(\".\");\n    var key = dormant ? \".\" : _createKey(args, customKey);\n    var watchId = useRef(-1);\n\n    if (watchId.current === -1) {\n      watchId.current = watchIdOrd++;\n    }\n\n    if (!dormant) {\n      if (!shouldUpdate.hasOwnProperty(key)) {\n        shouldUpdate[key] = _defineProperty({}, watchId.current, true);\n      } else {\n        shouldUpdate[key][watchId.current] = true;\n      }\n    }\n\n    var cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n    var stores;\n    var customContext;\n\n    if (onServer || forceContext) {\n      var pullstateContext = useContext(PullstateContext);\n      stores = pullstateContext.stores;\n      customContext = pullstateContext.customContext;\n    } else if (clientStores.loaded) {\n      stores = clientStores.stores;\n    } else {\n      stores = storeErrorProxy;\n    }\n\n    if (!onServer) {\n      var onAsyncStateChanged = function onAsyncStateChanged() {\n        if (shouldUpdate[key][watchId.current] && !isEqual(responseRef.current, cache.results[key])) {\n          responseRef.current = checkKeyAndReturnResponse({\n            key: key,\n            cache: cache,\n            initiate: initiate,\n            ssr: ssr,\n            args: args,\n            stores: stores,\n            fromListener: true,\n            postActionEnabled: postActionEnabled,\n            cacheBreakEnabled: cacheBreakEnabled,\n            holdingResult: undefined,\n            customContext: customContext,\n            holdPrevious: holdPrevious\n          });\n          setWatchUpdate(function (prev) {\n            return prev + 1;\n          });\n        }\n      };\n\n      if (!dormant) {\n        if (!cache.listeners.hasOwnProperty(key)) {\n          cache.listeners[key] = {};\n        }\n\n        cache.listeners[key][watchId.current] = onAsyncStateChanged;\n        shouldUpdate[key][watchId.current] = true;\n      }\n\n      useEffect(function () {\n        if (!dormant) {\n          cache.listeners[key][watchId.current] = onAsyncStateChanged;\n          shouldUpdate[key][watchId.current] = true;\n        }\n\n        return function () {\n          if (!dormant) {\n            delete cache.listeners[key][watchId.current];\n            shouldUpdate[key][watchId.current] = false;\n          }\n        };\n      }, [key]);\n    }\n\n    var _useState5 = useState(0),\n        _useState6 = _slicedToArray(_useState5, 2),\n        _ = _useState6[0],\n        setWatchUpdate = _useState6[1];\n\n    if (dormant) {\n      responseRef.current = holdPrevious && responseRef.current && responseRef.current[1] ? responseRef.current : [false, false, {\n        message: \"\",\n        tags: [EAsyncEndTags.DORMANT],\n        error: true,\n        payload: null\n      }, false, -1];\n      prevKeyRef.current = \".\";\n    } else if (prevKeyRef.current !== key) {\n      if (prevKeyRef.current !== null && shouldUpdate.hasOwnProperty(prevKeyRef.current)) {\n        delete cache.listeners[prevKeyRef.current][watchId.current];\n        shouldUpdate[prevKeyRef.current][watchId.current] = false;\n      }\n\n      prevKeyRef.current = key;\n      responseRef.current = checkKeyAndReturnResponse({\n        key: key,\n        cache: cache,\n        initiate: initiate,\n        ssr: ssr,\n        args: args,\n        stores: stores,\n        fromListener: false,\n        postActionEnabled: postActionEnabled,\n        cacheBreakEnabled: cacheBreakEnabled,\n        holdingResult: holdPrevious && responseRef.current && responseRef.current[1] ? responseRef.current : undefined,\n        customContext: customContext,\n        customCacheBreak: typeof customCacheBreak === \"boolean\" ? function () {\n          return customCacheBreak;\n        } : customCacheBreak,\n        holdPrevious: holdPrevious\n      });\n    }\n\n    return responseRef.current;\n  };\n\n  var useBeckon = function useBeckon() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref12 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref12$ssr = _ref12.ssr,\n        ssr = _ref12$ssr === void 0 ? true : _ref12$ssr,\n        _ref12$postActionEnab = _ref12.postActionEnabled,\n        postActionEnabled = _ref12$postActionEnab === void 0 ? true : _ref12$postActionEnab,\n        _ref12$cacheBreakEnab = _ref12.cacheBreakEnabled,\n        cacheBreakEnabled = _ref12$cacheBreakEnab === void 0 ? true : _ref12$cacheBreakEnab,\n        _ref12$holdPrevious = _ref12.holdPrevious,\n        holdPrevious = _ref12$holdPrevious === void 0 ? false : _ref12$holdPrevious,\n        _ref12$dormant = _ref12.dormant,\n        dormant = _ref12$dormant === void 0 ? false : _ref12$dormant,\n        key = _ref12.key;\n\n    var result = useWatch(args, {\n      initiate: true,\n      ssr: ssr,\n      postActionEnabled: postActionEnabled,\n      cacheBreakEnabled: cacheBreakEnabled,\n      holdPrevious: holdPrevious,\n      dormant: dormant,\n      key: key\n    });\n    return [result[1], result[2], result[3]];\n  };\n\n  var run = /*#__PURE__*/function () {\n    var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var args,\n          inputs,\n          _inputs$treatAsUpdate,\n          treatAsUpdate,\n          _inputs$ignoreShortCi,\n          ignoreShortCircuit,\n          _inputs$respectCache,\n          respectCache,\n          customKey,\n          _inputs$_asyncCache,\n          _asyncCache,\n          _inputs$_stores,\n          _stores,\n          _customContext,\n          customCacheBreak,\n          key,\n          cached,\n          watchOrd,\n          shortCircuitResponse,\n          _ref14,\n          _ref15,\n          prevFinished,\n          prevResp,\n          prevUpdate,\n          prevCacheTime,\n          currentActionOrd,\n          _args2 = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              args = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n              inputs = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n              _inputs$treatAsUpdate = inputs.treatAsUpdate, treatAsUpdate = _inputs$treatAsUpdate === void 0 ? false : _inputs$treatAsUpdate, _inputs$ignoreShortCi = inputs.ignoreShortCircuit, ignoreShortCircuit = _inputs$ignoreShortCi === void 0 ? false : _inputs$ignoreShortCi, _inputs$respectCache = inputs.respectCache, respectCache = _inputs$respectCache === void 0 ? false : _inputs$respectCache, customKey = inputs.key, _inputs$_asyncCache = inputs._asyncCache, _asyncCache = _inputs$_asyncCache === void 0 ? clientAsyncCache : _inputs$_asyncCache, _inputs$_stores = inputs._stores, _stores = _inputs$_stores === void 0 ? clientStores.loaded ? clientStores.stores : storeErrorProxy : _inputs$_stores, _customContext = inputs._customContext, customCacheBreak = inputs.cacheBreak;\n              key = _createKey(args, customKey);\n\n              if (!respectCache) {\n                _context2.next = 12;\n                break;\n              }\n\n              cached = getCachedResult({\n                key: key,\n                cache: _asyncCache,\n                args: args,\n                stores: _stores,\n                context: EPostActionContext.RUN_HIT_CACHE,\n                postActionEnabled: true,\n                cacheBreakEnabled: true,\n                fromListener: false,\n                customCacheBreak: typeof customCacheBreak === \"boolean\" ? function () {\n                  return customCacheBreak;\n                } : customCacheBreak\n              });\n\n              if (!(cached.response && cached.response[0])) {\n                _context2.next = 12;\n                break;\n              }\n\n              if (cached.response[1]) {\n                _context2.next = 11;\n                break;\n              }\n\n              watchOrd = watchIdOrd++;\n\n              if (!_asyncCache.listeners.hasOwnProperty(key)) {\n                _asyncCache.listeners[key] = {};\n              }\n\n              return _context2.abrupt(\"return\", new Promise(function (resolve) {\n                _asyncCache.listeners[key][watchOrd] = function () {\n                  var _asyncCache$results$k = _slicedToArray(_asyncCache.results[key], 3),\n                      finished = _asyncCache$results$k[1],\n                      resp = _asyncCache$results$k[2];\n\n                  if (finished) {\n                    delete _asyncCache.listeners[key][watchOrd];\n                    resolve(resp);\n                  }\n                };\n              }));\n\n            case 11:\n              return _context2.abrupt(\"return\", cached.response[2]);\n\n            case 12:\n              if (!(!ignoreShortCircuit && shortCircuitHook !== undefined)) {\n                _context2.next = 19;\n                break;\n              }\n\n              shortCircuitResponse = shortCircuitHook({\n                args: args,\n                stores: _stores\n              });\n\n              if (!(shortCircuitResponse !== false)) {\n                _context2.next = 19;\n                break;\n              }\n\n              _asyncCache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\n              runPostActionHook(shortCircuitResponse, args, _stores, EPostActionContext.SHORT_CIRCUIT);\n              notifyListeners(key);\n              return _context2.abrupt(\"return\", shortCircuitResponse);\n\n            case 19:\n              _ref14 = _asyncCache.results[key] || [false, false, {\n                error: true,\n                message: \"\",\n                payload: null,\n                tags: [EAsyncEndTags.UNFINISHED]\n              }, false, -1], _ref15 = _slicedToArray(_ref14, 5), prevFinished = _ref15[1], prevResp = _ref15[2], prevUpdate = _ref15[3], prevCacheTime = _ref15[4];\n\n              if (prevFinished && treatAsUpdate) {\n                _asyncCache.results[key] = [true, true, prevResp, true, prevCacheTime];\n              } else {\n                _asyncCache.results[key] = [true, false, {\n                  error: true,\n                  message: \"\",\n                  payload: null,\n                  tags: [EAsyncEndTags.UNFINISHED]\n                }, false, -1];\n              }\n\n              currentActionOrd = actionOrdUpdate(_asyncCache, key);\n              _asyncCache.actions[key] = createInternalAction(key, _asyncCache, args, _stores, currentActionOrd, true, EPostActionContext.DIRECT_RUN, _customContext);\n              notifyListeners(key);\n              return _context2.abrupt(\"return\", _asyncCache.actions[key]());\n\n            case 25:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function run() {\n      return _ref13.apply(this, arguments);\n    };\n  }();\n\n  var clearCache = function clearCache() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref16 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        customKey = _ref16.key,\n        _ref16$notify = _ref16.notify,\n        notify = _ref16$notify === void 0 ? true : _ref16$notify;\n\n    var key = _createKey(args, customKey);\n\n    clearActionCache(key, true, notify);\n  };\n\n  var clearAllCache = function clearAllCache() {\n    var _ref17 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref17$notify = _ref17.notify,\n        notify = _ref17$notify === void 0 ? true : _ref17$notify;\n\n    for (var _i2 = 0, _Object$keys2 = Object.keys(clientAsyncCache.actionOrd); _i2 < _Object$keys2.length; _i2++) {\n      var key = _Object$keys2[_i2];\n\n      if (key.startsWith(\"\".concat(ordinal, \"-\"))) {\n        clearActionCache(key, true, notify);\n      }\n    }\n  };\n\n  var clearAllUnwatchedCache = function clearAllUnwatchedCache() {\n    var _ref18 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref18$notify = _ref18.notify,\n        notify = _ref18$notify === void 0 ? true : _ref18$notify;\n\n    for (var _i3 = 0, _Object$keys3 = Object.keys(shouldUpdate); _i3 < _Object$keys3.length; _i3++) {\n      var key = _Object$keys3[_i3];\n\n      if (!Object.values(shouldUpdate[key]).some(function (su) {\n        return su;\n      })) {\n        delete shouldUpdate[key];\n        clearActionCache(key, false, notify);\n      }\n    }\n  };\n\n  var _setCached = function setCached(args, result, options) {\n    var _ref19 = options || {},\n        _ref19$notify = _ref19.notify,\n        notify = _ref19$notify === void 0 ? true : _ref19$notify,\n        customKey = _ref19.key;\n\n    var key = _createKey(args, customKey);\n\n    var cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n    cache.results[key] = [true, true, result, false, Date.now()];\n\n    if (notify) {\n      notifyListeners(key);\n    }\n  };\n\n  var _setCachedPayload = function setCachedPayload(args, payload, options) {\n    return _setCached(args, successResult(payload), options);\n  };\n\n  var _updateCached = function updateCached(args, updater, options) {\n    var _ref20 = options || {},\n        _ref20$notify = _ref20.notify,\n        notify = _ref20$notify === void 0 ? true : _ref20$notify,\n        _ref20$resetTimeCache = _ref20.resetTimeCached,\n        resetTimeCached = _ref20$resetTimeCache === void 0 ? true : _ref20$resetTimeCache,\n        _ref20$runPostActionH = _ref20.runPostActionHook,\n        postAction = _ref20$runPostActionH === void 0 ? false : _ref20$runPostActionH,\n        customKey = _ref20.key;\n\n    var key = _createKey(args, customKey);\n\n    var cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n\n    if (cache.results.hasOwnProperty(key) && !cache.results[key][2].error) {\n      var currentCached = cache.results[key][2].payload;\n      var newResult = {\n        payload: produce$1(currentCached, function (s) {\n          return updater(s, currentCached);\n        }),\n        error: false,\n        message: cache.results[key][2].message,\n        tags: cache.results[key][2].tags\n      };\n\n      if (postAction) {\n        runPostActionHook(newResult, args, clientStores.loaded ? clientStores.stores : storeErrorProxy, EPostActionContext.CACHE_UPDATE);\n      }\n\n      cache.results[key] = [true, true, newResult, cache.results[key][3], resetTimeCached ? Date.now() : cache.results[key][4]];\n\n      if (notify) {\n        notifyListeners(key);\n      }\n    }\n  };\n\n  var getCached = function getCached() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 ? arguments[1] : undefined;\n\n    var _ref21 = options || {},\n        _ref21$checkCacheBrea = _ref21.checkCacheBreak,\n        checkCacheBreak = _ref21$checkCacheBrea === void 0 ? false : _ref21$checkCacheBrea,\n        customKey = _ref21.key;\n\n    var key = _createKey(args, customKey);\n\n    var cacheBreakable = false;\n    var cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n\n    if (cache.results.hasOwnProperty(key)) {\n      if (checkCacheBreak && cacheBreakHook !== undefined) {\n        var stores = onServer ? useContext(PullstateContext).stores : clientStores.loaded ? clientStores.stores : storeErrorProxy;\n\n        if (cacheBreakHook({\n          args: args,\n          result: cache.results[key][2],\n          stores: stores,\n          timeCached: cache.results[key][4]\n        })) {\n          cacheBreakable = true;\n        }\n      }\n\n      var _cache$results$key = _slicedToArray(cache.results[key], 5),\n          started = _cache$results$key[0],\n          finished = _cache$results$key[1],\n          result = _cache$results$key[2],\n          updating = _cache$results$key[3],\n          timeCached = _cache$results$key[4];\n\n      return {\n        started: started,\n        finished: finished,\n        result: result,\n        existed: true,\n        cacheBreakable: cacheBreakable,\n        updating: updating,\n        timeCached: timeCached\n      };\n    } else {\n      return {\n        started: false,\n        finished: false,\n        result: {\n          message: \"\",\n          tags: [EAsyncEndTags.UNFINISHED],\n          error: true,\n          payload: null,\n          errorPayload: null\n        },\n        updating: false,\n        existed: false,\n        cacheBreakable: cacheBreakable,\n        timeCached: -1\n      };\n    }\n  };\n\n  var delayedRunActionTimeout;\n\n  var delayedRun = function delayedRun() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref22 = arguments.length > 1 ? arguments[1] : undefined,\n        _ref22$clearOldRun = _ref22.clearOldRun,\n        clearOldRun = _ref22$clearOldRun === void 0 ? true : _ref22$clearOldRun,\n        delay = _ref22.delay,\n        _ref22$immediateIfCac = _ref22.immediateIfCached,\n        immediateIfCached = _ref22$immediateIfCac === void 0 ? true : _ref22$immediateIfCac,\n        otherRunOptions = _objectWithoutProperties(_ref22, [\"clearOldRun\", \"delay\", \"immediateIfCached\"]);\n\n    if (clearOldRun) {\n      clearTimeout(delayedRunActionTimeout);\n    }\n\n    if (immediateIfCached) {\n      var _getCached = getCached(args, {\n        checkCacheBreak: true\n      }),\n          finished = _getCached.finished,\n          cacheBreakable = _getCached.cacheBreakable;\n\n      if (finished && !cacheBreakable) {\n        run(args, otherRunOptions);\n        return function () {};\n      }\n    }\n\n    var ref = {\n      cancelled: false\n    };\n    delayedRunActionTimeout = setTimeout(function () {\n      if (!ref.cancelled) {\n        run(args, otherRunOptions);\n      }\n    }, delay);\n    return function () {\n      ref.cancelled = true;\n    };\n  };\n\n  var use = function use() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref23 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref23$initiate = _ref23.initiate,\n        initiate = _ref23$initiate === void 0 ? true : _ref23$initiate,\n        _ref23$ssr = _ref23.ssr,\n        ssr = _ref23$ssr === void 0 ? true : _ref23$ssr,\n        postActionEnabled = _ref23.postActionEnabled,\n        cacheBreakEnabled = _ref23.cacheBreakEnabled,\n        _ref23$holdPrevious = _ref23.holdPrevious,\n        holdPrevious = _ref23$holdPrevious === void 0 ? false : _ref23$holdPrevious,\n        _ref23$dormant = _ref23.dormant,\n        dormant = _ref23$dormant === void 0 ? false : _ref23$dormant,\n        key = _ref23.key,\n        onSuccess = _ref23.onSuccess,\n        customCacheBreakHook = _ref23.cacheBreak;\n\n    if (postActionEnabled == null) {\n      postActionEnabled = initiate;\n    }\n\n    if (cacheBreakEnabled == null) {\n      cacheBreakEnabled = initiate;\n    }\n\n    var raw = useWatch(args, {\n      initiate: initiate,\n      ssr: ssr,\n      postActionEnabled: postActionEnabled,\n      cacheBreakEnabled: cacheBreakEnabled,\n      holdPrevious: holdPrevious,\n      dormant: dormant,\n      key: key,\n      cacheBreak: customCacheBreakHook\n    });\n\n    var _raw = _slicedToArray(raw, 4),\n        isStarted = _raw[0],\n        isFinished = _raw[1],\n        result = _raw[2],\n        isUpdating = _raw[3];\n\n    var isSuccess = isFinished && !result.error;\n    var isFailure = isFinished && result.error;\n\n    if (onSuccess) {\n      useEffect(function () {\n        if (isSuccess && !dormant) {\n          onSuccess(result.payload, args);\n        }\n      }, [isSuccess]);\n    }\n\n    var renderPayload = function renderPayload(func) {\n      if (!result.error) {\n        return func(result.payload);\n      }\n\n      return React.Fragment;\n    };\n\n    return {\n      isStarted: isStarted,\n      isFinished: isFinished,\n      isUpdating: isUpdating,\n      isSuccess: isSuccess,\n      isFailure: isFailure,\n      isLoading: isStarted && (!isFinished || isUpdating),\n      endTags: result.tags,\n      error: result.error,\n      payload: result.payload,\n      errorPayload: result.errorPayload,\n      renderPayload: renderPayload,\n      message: result.message,\n      raw: raw,\n      execute: function execute(runOptions) {\n        return run(args, runOptions);\n      },\n      clearCached: function clearCached() {\n        return clearCache(args);\n      },\n      setCached: function setCached(response, options) {\n        _setCached(args, response, options);\n      },\n      setCachedPayload: function setCachedPayload(payload, options) {\n        _setCachedPayload(args, payload, options);\n      },\n      updateCached: function updateCached(updater, options) {\n        _updateCached(args, updater, options);\n      }\n    };\n  };\n\n  var useDefer = function useDefer() {\n    var inputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _useState7 = useState(function () {\n      return {\n        key: inputs.key ? inputs.key : deferWaitingKey,\n        args: {}\n      };\n    }),\n        _useState8 = _slicedToArray(_useState7, 2),\n        argState = _useState8[0],\n        setArgState = _useState8[1];\n\n    var initialResponse = use({}, _objectSpread(_objectSpread({}, inputs), {}, {\n      key: argState.key,\n      initiate: false\n    }));\n    return _objectSpread(_objectSpread({}, initialResponse), {}, {\n      clearCached: function clearCached() {\n        clearCache({}, {\n          key: argState.key\n        });\n      },\n      unwatchExecuted: function unwatchExecuted() {\n        setArgState({\n          key: deferWaitingKey,\n          args: {}\n        });\n      },\n      setCached: function setCached(response) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        options.key = argState.key;\n\n        _setCached({}, response, options);\n      },\n      setCachedPayload: function setCachedPayload(payload) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        options.key = argState.key;\n\n        _setCachedPayload({}, payload, options);\n      },\n      updateCached: function updateCached(updater) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        options.key = argState.key;\n\n        _updateCached({}, updater, options);\n      },\n      execute: function execute() {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var runOptions = arguments.length > 1 ? arguments[1] : undefined;\n\n        var _a;\n\n        var executionKey = (_a = inputs.key) !== null && _a !== void 0 ? _a : _createKey(args);\n\n        if (executionKey !== argState.key) {\n          setArgState({\n            key: executionKey,\n            args: args\n          });\n        }\n\n        return run(args, _objectSpread(_objectSpread({}, runOptions), {}, {\n          key: executionKey,\n          cacheBreak: inputs.cacheBreak\n        })).then(function (resp) {\n          if (inputs.clearOnSuccess) {\n            clearCache({}, {\n              key: executionKey\n            });\n          }\n\n          return resp;\n        });\n      },\n      args: argState.args,\n      key: argState.key\n    });\n  };\n\n  return {\n    use: use,\n    useDefer: useDefer,\n    read: read,\n    useBeckon: useBeckon,\n    useWatch: useWatch,\n    run: run,\n    delayedRun: delayedRun,\n    clearCache: clearCache,\n    clearAllCache: clearAllCache,\n    clearAllUnwatchedCache: clearAllUnwatchedCache,\n    getCached: getCached,\n    setCached: _setCached,\n    setCachedPayload: _setCachedPayload,\n    updateCached: _updateCached\n  };\n}\n\nvar PullstateContext = React.createContext(null);\n\nvar PullstateProvider = function PullstateProvider(_ref24) {\n  var instance = _ref24.instance,\n      children = _ref24.children;\n  return React.createElement(PullstateContext.Provider, {\n    value: instance\n  }, children);\n};\n\nvar singleton = null;\nvar clientStores = {\n  internalClientStores: true,\n  loaded: false,\n  stores: {}\n};\n\nvar PullstateSingleton = /*#__PURE__*/function () {\n  function PullstateSingleton(allStores) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, PullstateSingleton);\n\n    this.options = {};\n\n    if (singleton !== null) {\n      console.error(\"Pullstate: createPullstate() - Should not be creating the core Pullstate class more than once! In order to re-use pull state, you need to call instantiate() on your already created object.\");\n    }\n\n    singleton = this;\n    clientStores.stores = allStores;\n    clientStores.loaded = true;\n    this.options = options;\n  }\n\n  _createClass(PullstateSingleton, [{\n    key: \"instantiate\",\n    value: function instantiate() {\n      var _ref25 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          hydrateSnapshot = _ref25.hydrateSnapshot,\n          _ref25$ssr = _ref25.ssr,\n          ssr = _ref25$ssr === void 0 ? false : _ref25$ssr,\n          customContext = _ref25.customContext;\n\n      if (!ssr) {\n        var instantiated = new PullstateInstance(clientStores.stores, false, customContext);\n\n        if (hydrateSnapshot != null) {\n          instantiated.hydrateFromSnapshot(hydrateSnapshot);\n        }\n\n        instantiated.instantiateReactions();\n        return instantiated;\n      }\n\n      var newStores = {};\n\n      for (var _i4 = 0, _Object$keys4 = Object.keys(clientStores.stores); _i4 < _Object$keys4.length; _i4++) {\n        var storeName = _Object$keys4[_i4];\n\n        if (hydrateSnapshot == null) {\n          newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\n        } else if (hydrateSnapshot.hasOwnProperty(storeName)) {\n          newStores[storeName] = new Store(hydrateSnapshot.allState[storeName]);\n        } else {\n          newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\n          console.warn(\"Pullstate (instantiate): store [\".concat(storeName, \"] didn't hydrate any state (data was non-existent on hydration object)\"));\n        }\n\n        newStores[storeName]._setInternalOptions({\n          ssr: ssr,\n          reactionCreators: clientStores.stores[storeName]._getReactionCreators()\n        });\n      }\n\n      return new PullstateInstance(newStores, true, customContext);\n    }\n  }, {\n    key: \"useStores\",\n    value: function useStores() {\n      return _useStores();\n    }\n  }, {\n    key: \"useInstance\",\n    value: function useInstance() {\n      return _useInstance();\n    }\n  }, {\n    key: \"createAsyncActionDirect\",\n    value: function createAsyncActionDirect(action) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _createAsyncActionDirect(action, options);\n    }\n  }, {\n    key: \"createAsyncAction\",\n    value: function createAsyncAction(action) {\n      var _this7 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _a;\n\n      if (((_a = this.options.asyncActions) === null || _a === void 0 ? void 0 : _a.defaultCachingSeconds) && !options.cacheBreakHook) {\n        options.cacheBreakHook = function (inputs) {\n          return inputs.timeCached < Date.now() - _this7.options.asyncActions.defaultCachingSeconds * 1000;\n        };\n      }\n\n      return _createAsyncAction(action, options);\n    }\n  }]);\n\n  return PullstateSingleton;\n}();\n\nvar PullstateInstance = /*#__PURE__*/function () {\n  function PullstateInstance(allStores, ssr, customContext) {\n    _classCallCheck(this, PullstateInstance);\n\n    this._ssr = false;\n    this._stores = {};\n    this._asyncCache = {\n      listeners: {},\n      results: {},\n      actions: {},\n      actionOrd: {}\n    };\n    this._stores = allStores;\n    this._ssr = ssr;\n    this._customContext = customContext;\n  }\n\n  _createClass(PullstateInstance, [{\n    key: \"getAllUnresolvedAsyncActions\",\n    value: function getAllUnresolvedAsyncActions() {\n      var _this8 = this;\n\n      return Object.keys(this._asyncCache.actions).map(function (key) {\n        return _this8._asyncCache.actions[key]();\n      });\n    }\n  }, {\n    key: \"instantiateReactions\",\n    value: function instantiateReactions() {\n      for (var _i5 = 0, _Object$keys5 = Object.keys(this._stores); _i5 < _Object$keys5.length; _i5++) {\n        var storeName = _Object$keys5[_i5];\n\n        this._stores[storeName]._instantiateReactions();\n      }\n    }\n  }, {\n    key: \"getPullstateSnapshot\",\n    value: function getPullstateSnapshot() {\n      var allState = {};\n\n      for (var _i6 = 0, _Object$keys6 = Object.keys(this._stores); _i6 < _Object$keys6.length; _i6++) {\n        var storeName = _Object$keys6[_i6];\n        allState[storeName] = this._stores[storeName].getRawState();\n      }\n\n      return {\n        allState: allState,\n        asyncResults: this._asyncCache.results,\n        asyncActionOrd: this._asyncCache.actionOrd\n      };\n    }\n  }, {\n    key: \"resolveAsyncState\",\n    value: function () {\n      var _resolveAsyncState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var promises;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                promises = this.getAllUnresolvedAsyncActions();\n                _context3.next = 3;\n                return Promise.all(promises);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function resolveAsyncState() {\n        return _resolveAsyncState.apply(this, arguments);\n      }\n\n      return resolveAsyncState;\n    }()\n  }, {\n    key: \"hasAsyncStateToResolve\",\n    value: function hasAsyncStateToResolve() {\n      return Object.keys(this._asyncCache.actions).length > 0;\n    }\n  }, {\n    key: \"stores\",\n    get: function get() {\n      return this._stores;\n    }\n  }, {\n    key: \"customContext\",\n    get: function get() {\n      return this._customContext;\n    }\n  }, {\n    key: \"runAsyncAction\",\n    value: function () {\n      var _runAsyncAction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(asyncAction) {\n        var args,\n            runOptions,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                args = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n                runOptions = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n\n                if (this._ssr) {\n                  runOptions._asyncCache = this._asyncCache;\n                  runOptions._stores = this._stores;\n                  runOptions._customContext = this._customContext;\n                }\n\n                _context4.next = 5;\n                return asyncAction.run(args, runOptions);\n\n              case 5:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function runAsyncAction(_x4) {\n        return _runAsyncAction.apply(this, arguments);\n      }\n\n      return runAsyncAction;\n    }()\n  }, {\n    key: \"hydrateFromSnapshot\",\n    value: function hydrateFromSnapshot(snapshot) {\n      for (var _i7 = 0, _Object$keys7 = Object.keys(this._stores); _i7 < _Object$keys7.length; _i7++) {\n        var storeName = _Object$keys7[_i7];\n\n        if (snapshot.allState.hasOwnProperty(storeName)) {\n          this._stores[storeName]._updateStateWithoutReaction(snapshot.allState[storeName]);\n        } else {\n          console.warn(\"\".concat(storeName, \" didn't hydrate any state (data was non-existent on hydration object)\"));\n        }\n      }\n\n      clientAsyncCache.results = snapshot.asyncResults || {};\n      clientAsyncCache.actionOrd = snapshot.asyncActionOrd || {};\n    }\n  }]);\n\n  return PullstateInstance;\n}();\n\nfunction createPullstateCore() {\n  var allStores = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new PullstateSingleton(allStores, options);\n}\n\nfunction _useStores() {\n  return useContext(PullstateContext).stores;\n}\n\nfunction _useInstance() {\n  return useContext(PullstateContext);\n}\n\nvar EAsyncActionInjectType;\n\n(function (EAsyncActionInjectType) {\n  EAsyncActionInjectType[\"WATCH\"] = \"watch\";\n  EAsyncActionInjectType[\"BECKON\"] = \"beckon\";\n})(EAsyncActionInjectType || (EAsyncActionInjectType = {}));\n\nfunction InjectAsyncAction(props) {\n  if (props.type === EAsyncActionInjectType.BECKON) {\n    var _response4 = props.action.useBeckon(props.args, props.options);\n\n    return props.children(_response4);\n  }\n\n  var response = props.action.useWatch(props.args, props.options);\n  return props.children(response);\n}\n\nfunction InjectStoreStateOpt(_ref26) {\n  var store = _ref26.store,\n      paths = _ref26.paths,\n      children = _ref26.children;\n  var state = useStoreStateOpt(store, paths);\n  return children(state);\n}\n\nfunction registerInDevtools(stores) {\n  var _ref27 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref27$namespace = _ref27.namespace,\n      namespace = _ref27$namespace === void 0 ? \"\" : _ref27$namespace;\n\n  var _a;\n\n  var devToolsExtension = typeof window !== \"undefined\" ? (_a = window) === null || _a === void 0 ? void 0 : _a.__REDUX_DEVTOOLS_EXTENSION__ : undefined;\n\n  if (devToolsExtension) {\n    var _loop = function _loop() {\n      var key = _Object$keys8[_i8];\n      var store = stores[key];\n      var devTools = devToolsExtension.connect({\n        name: \"\".concat(namespace).concat(key)\n      });\n      devTools.init(store.getRawState());\n      var ignoreNext = false;\n      store.subscribe(function (s) {\n        return s;\n      }, function (watched) {\n        if (ignoreNext) {\n          ignoreNext = false;\n          return;\n        }\n\n        devTools.send(\"Change\", watched);\n      });\n      devTools.subscribe(function (message) {\n        if (message.type === \"DISPATCH\" && message.state) {\n          ignoreNext = true;\n          var parsed = JSON.parse(message.state);\n          store.replace(parsed);\n        }\n      });\n    };\n\n    for (var _i8 = 0, _Object$keys8 = Object.keys(stores); _i8 < _Object$keys8.length; _i8++) {\n      _loop();\n    }\n  }\n}\n\nvar batchState = {};\n\nfunction setupBatch(_ref28) {\n  var uiBatchFunction = _ref28.uiBatchFunction;\n  batchState.uiBatchFunction = uiBatchFunction;\n}\n\nfunction batch(runUpdates) {\n  if (globalClientState.batching) {\n    throw new Error(\"Pullstate: Can't enact two batch() update functions at the same time-\\n\" + \"make sure you are not running a batch() inside of a batch() by mistake.\");\n  }\n\n  globalClientState.batching = true;\n\n  try {\n    runUpdates();\n  } finally {\n    if (batchState.uiBatchFunction) {\n      batchState.uiBatchFunction(function () {\n        Object.values(globalClientState.flushStores).forEach(function (store) {\n          return store.flushBatch(true);\n        });\n      });\n    } else {\n      Object.values(globalClientState.flushStores).forEach(function (store) {\n        return store.flushBatch(true);\n      });\n    }\n\n    globalClientState.flushStores = {};\n    globalClientState.batching = false;\n  }\n}\n\nexport { EAsyncActionInjectType, EAsyncEndTags, EPostActionContext, InjectAsyncAction, InjectStoreState, InjectStoreStateOpt, PullstateContext, PullstateProvider, Store, batch, _createAsyncAction as createAsyncAction, _createAsyncActionDirect as createAsyncActionDirect, createPullstateCore, errorResult, registerInDevtools, setupBatch, successResult, _update as update, _useInstance as useInstance, useLocalStore, useStoreState, useStoreStateOpt, _useStores as useStores };","map":{"version":3,"sources":["D:/mobilecross/Ajege/node_modules/pullstate/dist/index.es.js"],"names":["isEqual","React","useRef","useState","useEffect","useContext","produce$1","enablePatches","produceWithPatches","produce","applyPatches","useStoreState","store","getSubState","deps","updateRef","state","undefined","initialized","current","getRawState","setUpdateTrigger","effectState","shouldUpdate","update","nextSubState","val","_addUpdateListener","_removeUpdateListener","prevDeps","updateListenerOrd","fastGet","obj","path","reduce","cur","key","getSubStateFromPaths","paths","resp","push","useStoreStateOpt","subState","setSubState","onStoreUpdate","currentSubState","ordKey","onStoreUpdateOpt","_addUpdateListenerOpt","_removeUpdateListenerOpt","useLocalStore","initialState","storeRef","Store","globalClientState","storeOrdinal","batching","flushStores","makeSubscriptionFunction","watch","listener","lastWatchState","currentState","nextWatchState","makeReactionFunctionCreator","reaction","forceRun","_optListenerCount","s","nextState","patches","inversePatches","_updateStateWithoutReaction","length","_patchListeners","forEach","Object","keys","getChangedPathsFromPatches","optPathDivider","updateListeners","ssr","reactions","clientSubscriptions","reactionCreators","optimizedUpdateListeners","optimizedUpdateListenerPaths","optimizedListenerPropertyMap","Function","createInitialState","internalOrdId","map","rc","updateKeyedPaths","batchState","runReaction","runSubscription","updateOrds","Set","keyedPath","ord","add","values","listenerPathsKeyed","join","filter","f","patchListener","func","console","warn","runNow","runNowWithSideEffects","creator","_updateState","ignoreError","error","updater","patchesCallback","runUpdates","newState","applyPatchesToStore","changePatches","prev","patch","curKey","p","currentValue","ns","previousValue","currentUpdater","InjectStoreState","on","children","EAsyncEndTags","EPostActionContext","clientAsyncCache","listeners","results","actions","actionOrd","asyncCreationOrdinal","keyFromObject","json","typeOf","prefix","sort","notifyListeners","hasOwnProperty","watchId","clearActionCache","clearPending","notify","actionOrdUpdate","cache","successResult","payload","tags","message","errorPayload","errorResult","RETURNED_ERROR","PullstateAsyncError","Error","storeErrorProxy","Proxy","get","prop","String","startedButUnfinishedResult","UNFINISHED","createAsyncActionDirect","action","options","createAsyncAction","args","stores","customContext","forceContext","shortCircuitHook","cacheBreakHook","postActionHook","subsetKey","actionId","ordinal","onServer","window","_createKey","customKey","deferWaitingKey","cacheBreakWatcher","watchIdOrd","runPostActionHook","result","context","getCachedResult","cacheBreakEnabled","fromListener","postActionEnabled","customCacheBreak","useCacheBreakHook","cacheBreakLoop","timeCached","previous","cacheBroke","response","createInternalAction","currentActionOrd","executionContext","then","Date","now","catch","e","THREW_ERROR","checkKeyAndReturnResponse","initiate","holdingResult","holdPrevious","cached","BECKON_HIT_CACHE","WATCH_HIT_CACHE","shortCircuitResponse","SHORT_CIRCUIT","BECKON_RUN","read","PullstateContext","_asyncCache","pullstateContext","clientStores","loaded","READ_HIT_CACHE","READ_RUN","watchOrd","Promise","resolve","useWatch","dormant","cacheBreak","responseRef","prevKeyRef","onAsyncStateChanged","setWatchUpdate","_","DORMANT","useBeckon","run","inputs","treatAsUpdate","ignoreShortCircuit","respectCache","_stores","_customContext","RUN_HIT_CACHE","finished","prevFinished","prevResp","prevUpdate","prevCacheTime","DIRECT_RUN","clearCache","clearAllCache","startsWith","clearAllUnwatchedCache","some","su","setCached","setCachedPayload","updateCached","resetTimeCached","postAction","currentCached","newResult","CACHE_UPDATE","getCached","checkCacheBreak","cacheBreakable","started","updating","existed","delayedRunActionTimeout","delayedRun","clearOldRun","delay","immediateIfCached","otherRunOptions","clearTimeout","ref","cancelled","setTimeout","use","onSuccess","customCacheBreakHook","raw","isStarted","isFinished","isUpdating","isSuccess","isFailure","renderPayload","Fragment","isLoading","endTags","execute","runOptions","clearCached","useDefer","argState","setArgState","initialResponse","unwatchExecuted","_a","executionKey","clearOnSuccess","createContext","PullstateProvider","instance","createElement","Provider","value","singleton","internalClientStores","PullstateSingleton","allStores","hydrateSnapshot","instantiated","PullstateInstance","hydrateFromSnapshot","instantiateReactions","newStores","storeName","_getInitialState","allState","_setInternalOptions","_getReactionCreators","useStores","useInstance","asyncActions","defaultCachingSeconds","_ssr","_instantiateReactions","asyncResults","asyncActionOrd","promises","getAllUnresolvedAsyncActions","all","asyncAction","snapshot","createPullstateCore","EAsyncActionInjectType","InjectAsyncAction","props","type","BECKON","InjectStoreStateOpt","registerInDevtools","namespace","devToolsExtension","__REDUX_DEVTOOLS_EXTENSION__","devTools","connect","name","init","ignoreNext","subscribe","watched","send","parsed","JSON","parse","replace","setupBatch","uiBatchFunction","batch","flushBatch"],"mappings":"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","sourcesContent":["import isEqual from'fast-deep-equal/es6';import React,{useRef,useState,useEffect,useContext}from'react';import produce$1,{enablePatches,produceWithPatches,produce,applyPatches}from'immer';function useStoreState(store, getSubState, deps) {\r\n    const updateRef = useRef({ state: undefined, initialized: false });\r\n    if (!updateRef.current.initialized) {\r\n        updateRef.current.state = getSubState ? getSubState(store.getRawState()) : store.getRawState();\r\n        updateRef.current.initialized = true;\r\n    }\r\n    const [, setUpdateTrigger] = useState(0);\r\n    useEffect(() => {\r\n        const effectState = { shouldUpdate: true };\r\n        function update() {\r\n            if (effectState.shouldUpdate) {\r\n                const nextSubState = getSubState\r\n                    ? getSubState(store.getRawState())\r\n                    : store.getRawState();\r\n                if (!isEqual(updateRef.current.state, nextSubState)) {\r\n                    if (effectState.shouldUpdate) {\r\n                        updateRef.current.state = nextSubState;\r\n                        setUpdateTrigger((val) => val + 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        store._addUpdateListener(update);\r\n        update();\r\n        return () => {\r\n            effectState.shouldUpdate = false;\r\n            store._removeUpdateListener(update);\r\n        };\r\n    }, deps !== null && deps !== void 0 ? deps : []);\r\n    if (deps !== undefined) {\r\n        const prevDeps = useRef(deps);\r\n        if (!isEqual(deps, prevDeps)) {\r\n            updateRef.current.state = getSubState(store.getRawState());\r\n        }\r\n    }\r\n    return updateRef.current.state;\r\n}let updateListenerOrd = 0;\r\nfunction fastGet(obj, path) {\r\n    return path.reduce((cur = obj, key) => {\r\n        return cur[key];\r\n    }, undefined);\r\n}\r\nfunction getSubStateFromPaths(store, paths) {\r\n    const state = store.getRawState();\r\n    const resp = [];\r\n    for (const path of paths) {\r\n        resp.push(fastGet(state, path));\r\n    }\r\n    return resp;\r\n}\r\nfunction useStoreStateOpt(store, paths) {\r\n    const [subState, setSubState] = useState(() => getSubStateFromPaths(store, paths));\r\n    const updateRef = useRef({\r\n        shouldUpdate: true,\r\n        onStoreUpdate: null,\r\n        currentSubState: null,\r\n        ordKey: `_${updateListenerOrd++}`,\r\n    });\r\n    updateRef.current.currentSubState = subState;\r\n    if (updateRef.current.onStoreUpdate === null) {\r\n        updateRef.current.onStoreUpdate = function onStoreUpdateOpt() {\r\n            if (updateRef.current.shouldUpdate) {\r\n                setSubState(getSubStateFromPaths(store, paths));\r\n            }\r\n        };\r\n        store._addUpdateListenerOpt(updateRef.current.onStoreUpdate, updateRef.current.ordKey, paths);\r\n    }\r\n    useEffect(() => () => {\r\n        updateRef.current.shouldUpdate = false;\r\n        store._removeUpdateListenerOpt(updateRef.current.ordKey);\r\n    }, []);\r\n    return subState;\r\n}function useLocalStore(initialState, deps) {\r\n    const storeRef = useRef();\r\n    if (storeRef.current == null) {\r\n        storeRef.current = new Store(initialState);\r\n    }\r\n    if (deps !== undefined) {\r\n        const prevDeps = useRef(deps);\r\n        if (!isEqual(deps, prevDeps)) {\r\n            storeRef.current = new Store(initialState);\r\n        }\r\n    }\r\n    return storeRef.current;\r\n}const globalClientState = {\r\n    storeOrdinal: 0,\r\n    batching: false,\r\n    flushStores: {}\r\n};enablePatches();\r\nfunction makeSubscriptionFunction(store, watch, listener) {\r\n    let lastWatchState = watch(store.getRawState());\r\n    return () => {\r\n        const currentState = store.getRawState();\r\n        const nextWatchState = watch(currentState);\r\n        if (!isEqual(nextWatchState, lastWatchState)) {\r\n            listener(nextWatchState, currentState, lastWatchState);\r\n            lastWatchState = nextWatchState;\r\n        }\r\n    };\r\n}\r\nfunction makeReactionFunctionCreator(watch, reaction) {\r\n    return (store) => {\r\n        let lastWatchState = watch(store.getRawState());\r\n        return (forceRun = false) => {\r\n            const currentState = store.getRawState();\r\n            const nextWatchState = watch(currentState);\r\n            if (forceRun || !isEqual(nextWatchState, lastWatchState)) {\r\n                if (store._optListenerCount > 0) {\r\n                    const [nextState, patches, inversePatches] = produceWithPatches(currentState, (s) => reaction(nextWatchState, s, currentState, lastWatchState));\r\n                    store._updateStateWithoutReaction(nextState);\r\n                    lastWatchState = nextWatchState;\r\n                    if (patches.length > 0) {\r\n                        store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n                        return Object.keys(getChangedPathsFromPatches(patches));\r\n                    }\r\n                }\r\n                else {\r\n                    if (store._patchListeners.length > 0) {\r\n                        const [nextState, patches, inversePatches] = produceWithPatches(currentState, (s) => reaction(nextWatchState, s, currentState, lastWatchState));\r\n                        if (patches.length > 0) {\r\n                            store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n                        }\r\n                        store._updateStateWithoutReaction(nextState);\r\n                    }\r\n                    else {\r\n                        store._updateStateWithoutReaction(produce(currentState, (s) => reaction(nextWatchState, s, currentState, lastWatchState)));\r\n                    }\r\n                    lastWatchState = nextWatchState;\r\n                }\r\n            }\r\n            return [];\r\n        };\r\n    };\r\n}\r\nconst optPathDivider = \"~._.~\";\r\nclass Store {\r\n    constructor(initialState) {\r\n        this.updateListeners = [];\r\n        this.ssr = false;\r\n        this.reactions = [];\r\n        this.clientSubscriptions = [];\r\n        this.reactionCreators = [];\r\n        this.optimizedUpdateListeners = {};\r\n        this.optimizedUpdateListenerPaths = {};\r\n        this.optimizedListenerPropertyMap = {};\r\n        this._optListenerCount = 0;\r\n        this._patchListeners = [];\r\n        if (initialState instanceof Function) {\r\n            const state = initialState();\r\n            this.currentState = state;\r\n            this.initialState = state;\r\n            this.createInitialState = initialState;\r\n        }\r\n        else {\r\n            this.currentState = initialState;\r\n            this.initialState = initialState;\r\n            this.createInitialState = () => initialState;\r\n        }\r\n        this.internalOrdId = globalClientState.storeOrdinal++;\r\n    }\r\n    _setInternalOptions({ ssr, reactionCreators = [] }) {\r\n        this.ssr = ssr;\r\n        this.reactionCreators = reactionCreators;\r\n        this.reactions = reactionCreators.map((rc) => rc(this));\r\n    }\r\n    _getReactionCreators() {\r\n        return this.reactionCreators;\r\n    }\r\n    _instantiateReactions() {\r\n        this.reactions = this.reactionCreators.map((rc) => rc(this));\r\n    }\r\n    _getInitialState() {\r\n        return this.createInitialState();\r\n    }\r\n    _updateStateWithoutReaction(nextState) {\r\n        this.currentState = nextState;\r\n    }\r\n    _updateState(nextState, updateKeyedPaths = []) {\r\n        this.currentState = nextState;\r\n        this.batchState = undefined;\r\n        for (const runReaction of this.reactions) {\r\n            updateKeyedPaths.push(...runReaction());\r\n        }\r\n        if (!this.ssr) {\r\n            for (const runSubscription of this.clientSubscriptions) {\r\n                runSubscription();\r\n            }\r\n            if (updateKeyedPaths.length > 0) {\r\n                const updateOrds = new Set();\r\n                for (const keyedPath of updateKeyedPaths) {\r\n                    if (this.optimizedListenerPropertyMap[keyedPath]) {\r\n                        for (const ord of this.optimizedListenerPropertyMap[keyedPath]) {\r\n                            updateOrds.add(ord);\r\n                        }\r\n                    }\r\n                }\r\n                for (const ord of updateOrds.values()) {\r\n                    if (this.optimizedUpdateListeners[ord]) {\r\n                        this.optimizedUpdateListeners[ord]();\r\n                    }\r\n                }\r\n            }\r\n            this.updateListeners.forEach((listener) => listener());\r\n        }\r\n    }\r\n    _addUpdateListener(listener) {\r\n        this.updateListeners.push(listener);\r\n    }\r\n    _addUpdateListenerOpt(listener, ordKey, paths) {\r\n        this.optimizedUpdateListeners[ordKey] = listener;\r\n        const listenerPathsKeyed = paths.map((path) => path.join(optPathDivider));\r\n        this.optimizedUpdateListenerPaths[ordKey] = listenerPathsKeyed;\r\n        for (const keyedPath of listenerPathsKeyed) {\r\n            if (this.optimizedListenerPropertyMap[keyedPath] == null) {\r\n                this.optimizedListenerPropertyMap[keyedPath] = [ordKey];\r\n            }\r\n            else {\r\n                this.optimizedListenerPropertyMap[keyedPath].push(ordKey);\r\n            }\r\n        }\r\n        this._optListenerCount++;\r\n    }\r\n    _removeUpdateListener(listener) {\r\n        this.updateListeners = this.updateListeners.filter((f) => f !== listener);\r\n    }\r\n    _removeUpdateListenerOpt(ordKey) {\r\n        const listenerPathsKeyed = this.optimizedUpdateListenerPaths[ordKey];\r\n        for (const keyedPath of listenerPathsKeyed) {\r\n            this.optimizedListenerPropertyMap[keyedPath] = this.optimizedListenerPropertyMap[keyedPath].filter((ord) => ord !== ordKey);\r\n        }\r\n        delete this.optimizedUpdateListenerPaths[ordKey];\r\n        delete this.optimizedUpdateListeners[ordKey];\r\n        this._optListenerCount--;\r\n    }\r\n    listenToPatches(patchListener) {\r\n        this._patchListeners.push(patchListener);\r\n        return () => {\r\n            this._patchListeners = this._patchListeners.filter((f) => f !== patchListener);\r\n        };\r\n    }\r\n    subscribe(watch, listener) {\r\n        if (!this.ssr) {\r\n            const func = makeSubscriptionFunction(this, watch, listener);\r\n            this.clientSubscriptions.push(func);\r\n            return () => {\r\n                this.clientSubscriptions = this.clientSubscriptions.filter((f) => f !== func);\r\n            };\r\n        }\r\n        return () => {\r\n            console.warn(`Pullstate: Subscriptions made on the server side are not registered - so therefor this call to unsubscribe does nothing.`);\r\n        };\r\n    }\r\n    createReaction(watch, reaction, { runNow = false, runNowWithSideEffects = false } = {}) {\r\n        const creator = makeReactionFunctionCreator(watch, reaction);\r\n        this.reactionCreators.push(creator);\r\n        const func = creator(this);\r\n        this.reactions.push(func);\r\n        if (runNow || runNowWithSideEffects) {\r\n            func(true);\r\n            if (runNowWithSideEffects && !this.ssr) {\r\n                this._updateState(this.currentState);\r\n            }\r\n        }\r\n        return () => {\r\n            this.reactions = this.reactions.filter((f) => f !== func);\r\n        };\r\n    }\r\n    getRawState() {\r\n        if (this.batchState !== undefined) {\r\n            return this.batchState;\r\n        }\r\n        else {\r\n            return this.currentState;\r\n        }\r\n    }\r\n    useState(getSubState, deps) {\r\n        return useStoreState(this, getSubState, deps);\r\n    }\r\n    useLocalCopyInitial(deps) {\r\n        return useLocalStore(this.createInitialState, deps);\r\n    }\r\n    useLocalCopySnapshot(deps) {\r\n        return useLocalStore(this.currentState, deps);\r\n    }\r\n    flushBatch(ignoreError = false) {\r\n        if (this.batchState !== undefined) {\r\n            if (this.batchState !== this.currentState) {\r\n                this._updateState(this.batchState);\r\n            }\r\n        }\r\n        else if (!ignoreError) {\r\n            console.error(`Pullstate: Trying to flush batch state which was never created or updated on`);\r\n        }\r\n        this.batchState = undefined;\r\n    }\r\n    update(updater, patchesCallback) {\r\n        if (globalClientState.batching) {\r\n            if (this.batchState === undefined) {\r\n                this.batchState = this.currentState;\r\n                globalClientState.flushStores[this.internalOrdId] = this;\r\n            }\r\n            const func = typeof updater === \"function\";\r\n            const [nextState, patches, inversePatches] = runUpdates(this.batchState, updater, func);\r\n            if (patches.length > 0 && (this._patchListeners.length > 0 || patchesCallback)) {\r\n                if (patchesCallback) {\r\n                    patchesCallback(patches, inversePatches);\r\n                }\r\n                this._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n            }\r\n            this.batchState = nextState;\r\n        }\r\n        else {\r\n            this.batchState = undefined;\r\n            update(this, updater, patchesCallback);\r\n        }\r\n    }\r\n    replace(newState) {\r\n        this._updateState(newState);\r\n    }\r\n    applyPatches(patches) {\r\n        applyPatchesToStore(this, patches);\r\n    }\r\n}\r\nfunction applyPatchesToStore(store, patches) {\r\n    const currentState = store.getRawState();\r\n    const nextState = applyPatches(currentState, patches);\r\n    if (nextState !== currentState) {\r\n        store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\r\n    }\r\n}\r\nfunction getChangedPathsFromPatches(changePatches, prev = {}) {\r\n    for (const patch of changePatches) {\r\n        let curKey;\r\n        for (const p of patch.path) {\r\n            if (curKey) {\r\n                curKey = `${curKey}${optPathDivider}${p}`;\r\n            }\r\n            else {\r\n                curKey = p;\r\n            }\r\n            prev[curKey] = 1;\r\n        }\r\n    }\r\n    return prev;\r\n}\r\nfunction runUpdates(currentState, updater, func) {\r\n    return func\r\n        ? produceWithPatches(currentState, (s) => updater(s, currentState))\r\n        : updater.reduce(([nextState, patches, inversePatches], currentValue) => {\r\n            const resp = produceWithPatches(nextState, (s) => currentValue(s, nextState));\r\n            patches.push(...resp[1]);\r\n            inversePatches.push(...resp[2]);\r\n            return [resp[0], patches, inversePatches];\r\n        }, [currentState, [], []]);\r\n}\r\nfunction update(store, updater, patchesCallback) {\r\n    const currentState = store.getRawState();\r\n    const func = typeof updater === \"function\";\r\n    if (store._optListenerCount > 0) {\r\n        const [nextState, patches, inversePatches] = runUpdates(currentState, updater, func);\r\n        if (patches.length > 0) {\r\n            if (patchesCallback) {\r\n                patchesCallback(patches, inversePatches);\r\n            }\r\n            store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n            store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\r\n        }\r\n    }\r\n    else {\r\n        let nextState;\r\n        if (store._patchListeners.length > 0 || patchesCallback) {\r\n            const [ns, patches, inversePatches] = runUpdates(currentState, updater, func);\r\n            if (patches.length > 0) {\r\n                if (patchesCallback) {\r\n                    patchesCallback(patches, inversePatches);\r\n                }\r\n                store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n            }\r\n            nextState = ns;\r\n        }\r\n        else {\r\n            nextState = produce(currentState, (s) => func\r\n                ? updater(s, currentState)\r\n                : updater.reduce((previousValue, currentUpdater) => {\r\n                    return produce(previousValue, (s) => currentUpdater(s, previousValue));\r\n                }, currentState));\r\n        }\r\n        if (nextState !== currentState) {\r\n            store._updateState(nextState);\r\n        }\r\n    }\r\n}function InjectStoreState({ store, on = s => s, children, }) {\r\n    const state = useStoreState(store, on);\r\n    return children(state);\r\n}var EAsyncEndTags;\r\n(function (EAsyncEndTags) {\r\n    EAsyncEndTags[\"THREW_ERROR\"] = \"THREW_ERROR\";\r\n    EAsyncEndTags[\"RETURNED_ERROR\"] = \"RETURNED_ERROR\";\r\n    EAsyncEndTags[\"UNFINISHED\"] = \"UNFINISHED\";\r\n    EAsyncEndTags[\"DORMANT\"] = \"DORMANT\";\r\n})(EAsyncEndTags || (EAsyncEndTags = {}));\r\nvar EPostActionContext;\r\n(function (EPostActionContext) {\r\n    EPostActionContext[\"WATCH_HIT_CACHE\"] = \"WATCH_HIT_CACHE\";\r\n    EPostActionContext[\"BECKON_HIT_CACHE\"] = \"BECKON_HIT_CACHE\";\r\n    EPostActionContext[\"RUN_HIT_CACHE\"] = \"RUN_HIT_CACHE\";\r\n    EPostActionContext[\"READ_HIT_CACHE\"] = \"READ_HIT_CACHE\";\r\n    EPostActionContext[\"READ_RUN\"] = \"READ_RUN\";\r\n    EPostActionContext[\"SHORT_CIRCUIT\"] = \"SHORT_CIRCUIT\";\r\n    EPostActionContext[\"DIRECT_RUN\"] = \"DIRECT_RUN\";\r\n    EPostActionContext[\"BECKON_RUN\"] = \"BECKON_RUN\";\r\n    EPostActionContext[\"CACHE_UPDATE\"] = \"CACHE_UPDATE\";\r\n})(EPostActionContext || (EPostActionContext = {}));const clientAsyncCache = {\r\n    listeners: {},\r\n    results: {},\r\n    actions: {},\r\n    actionOrd: {}\r\n};\r\nlet asyncCreationOrdinal = 0;\r\nfunction keyFromObject(json) {\r\n    if (json === null) {\r\n        return \"(n)\";\r\n    }\r\n    const typeOf = typeof json;\r\n    if (typeOf !== \"object\") {\r\n        if (typeOf === \"undefined\") {\r\n            return \"(u)\";\r\n        }\r\n        else if (typeOf === \"string\") {\r\n            return \":\" + json + \";\";\r\n        }\r\n        else if (typeOf === \"boolean\" || typeOf === \"number\") {\r\n            return \"(\" + json + \")\";\r\n        }\r\n    }\r\n    let prefix = \"{\";\r\n    for (const key of Object.keys(json).sort()) {\r\n        prefix += key + keyFromObject(json[key]);\r\n    }\r\n    return prefix + \"}\";\r\n}\r\nfunction notifyListeners(key) {\r\n    if (clientAsyncCache.listeners.hasOwnProperty(key)) {\r\n        for (const watchId of Object.keys(clientAsyncCache.listeners[key])) {\r\n            clientAsyncCache.listeners[key][watchId]();\r\n        }\r\n    }\r\n}\r\nfunction clearActionCache(key, clearPending = true, notify = true) {\r\n    if (clearPending && clientAsyncCache.actionOrd.hasOwnProperty(key)) {\r\n        clientAsyncCache.actionOrd[key] += 1;\r\n    }\r\n    delete clientAsyncCache.results[key];\r\n    if (notify) {\r\n        notifyListeners(key);\r\n    }\r\n}\r\nfunction actionOrdUpdate(cache, key) {\r\n    if (!cache.actionOrd.hasOwnProperty(key)) {\r\n        cache.actionOrd[key] = 0;\r\n    }\r\n    else {\r\n        cache.actionOrd[key] += 1;\r\n    }\r\n    return cache.actionOrd[key];\r\n}\r\nfunction successResult(payload = null, tags = [], message = \"\") {\r\n    return {\r\n        payload,\r\n        tags,\r\n        message,\r\n        error: false,\r\n        errorPayload: null\r\n    };\r\n}\r\nfunction errorResult(tags = [], message = \"\", errorPayload) {\r\n    return {\r\n        payload: null,\r\n        tags: [EAsyncEndTags.RETURNED_ERROR, ...tags],\r\n        message,\r\n        error: true,\r\n        errorPayload: errorPayload\r\n    };\r\n}\r\nclass PullstateAsyncError extends Error {\r\n    constructor(message, tags) {\r\n        super(message);\r\n        this.tags = tags;\r\n    }\r\n}\r\nlet storeErrorProxy;\r\ntry {\r\n    storeErrorProxy = new Proxy({}, {\r\n        get: function (obj, prop) {\r\n            throw new Error(`Pullstate: Trying to access store (${String(prop)}) inside async actions without the correct usage or setup.\r\nIf this error occurred on the server:\r\n* If using run(), make use of your created instance for this request: instance.runAsyncAction()\r\n* If using read(), useWatch(), useBeckon() etc. - make sure you have properly set up your <PullstateProvider/>\r\n\r\nIf this error occurred on the client:\r\n* Make sure you have created your \"pullstateCore\" object with all your stores, using createPullstateCore(), and are making use of instantiate() before rendering.`);\r\n        }\r\n    });\r\n}\r\ncatch {\r\n    storeErrorProxy = {};\r\n}\r\nconst startedButUnfinishedResult = [\r\n    true,\r\n    false,\r\n    {\r\n        message: \"\",\r\n        tags: [EAsyncEndTags.UNFINISHED],\r\n        error: true,\r\n        payload: null,\r\n        errorPayload: null\r\n    },\r\n    false,\r\n    -1\r\n];\r\nfunction createAsyncActionDirect(action, options = {}) {\r\n    return createAsyncAction(async (args, stores, customContext) => {\r\n        return successResult(await action(args, stores, customContext));\r\n    }, options);\r\n}\r\nfunction createAsyncAction(action, { forceContext = false, shortCircuitHook, cacheBreakHook, postActionHook, subsetKey, actionId } = {}) {\r\n    const ordinal = actionId != null ? `_${actionId}` : asyncCreationOrdinal++;\r\n    const onServer = typeof window === \"undefined\";\r\n    function _createKey(args, customKey) {\r\n        if (customKey != null) {\r\n            return `${ordinal}-c-${customKey}`;\r\n        }\r\n        if (subsetKey !== undefined) {\r\n            return `${ordinal}-${keyFromObject(subsetKey(args))}`;\r\n        }\r\n        return `${ordinal}-${keyFromObject(args)}`;\r\n    }\r\n    const deferWaitingKey = `def_wait_${_createKey({})}`;\r\n    let cacheBreakWatcher = {};\r\n    let watchIdOrd = 0;\r\n    const shouldUpdate = {};\r\n    function runPostActionHook(result, args, stores, context) {\r\n        if (postActionHook !== undefined) {\r\n            postActionHook({ args, result, stores, context });\r\n        }\r\n    }\r\n    function getCachedResult({ args, cache, cacheBreakEnabled, context, fromListener, key, postActionEnabled, stores, customCacheBreak }) {\r\n        const useCacheBreakHook = customCacheBreak !== null && customCacheBreak !== void 0 ? customCacheBreak : cacheBreakHook;\r\n        if (cache.results.hasOwnProperty(key)) {\r\n            const cacheBreakLoop = cacheBreakWatcher.hasOwnProperty(key) && cacheBreakWatcher[key] > 2;\r\n            if (!onServer &&\r\n                !fromListener &&\r\n                cacheBreakEnabled &&\r\n                useCacheBreakHook != null\r\n                && cache.results[key][1] &&\r\n                useCacheBreakHook({\r\n                    args,\r\n                    result: cache.results[key][2],\r\n                    stores,\r\n                    timeCached: cache.results[key][4]\r\n                }) &&\r\n                !cacheBreakLoop) {\r\n                if (cacheBreakWatcher.hasOwnProperty(key)) {\r\n                    cacheBreakWatcher[key]++;\r\n                }\r\n                else {\r\n                    cacheBreakWatcher[key] = 1;\r\n                }\r\n                const previous = cache.results[key];\r\n                delete cache.results[key];\r\n                return { cacheBroke: true, response: undefined, previous };\r\n            }\r\n            else {\r\n                if (cacheBreakLoop) {\r\n                    console.error(`[${key}] Pullstate detected an infinite loop caused by cacheBreakHook()\r\nreturning true too often (breaking cache as soon as your action is resolving - hence\r\ncausing beckoned actions to run the action again) in one of your AsyncActions - Pullstate prevented\r\nfurther looping. Fix in your cacheBreakHook() is needed.`);\r\n                }\r\n                else {\r\n                    cacheBreakWatcher[key] = 0;\r\n                }\r\n                if (postActionEnabled && cache.results[key][1] && !fromListener) {\r\n                    runPostActionHook(cache.results[key][2], args, stores, context);\r\n                }\r\n                return {\r\n                    response: cache.results[key],\r\n                    cacheBroke: false,\r\n                    previous: undefined\r\n                };\r\n            }\r\n        }\r\n        return { cacheBroke: false, response: undefined, previous: undefined };\r\n    }\r\n    function createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, executionContext, customContext) {\r\n        return () => action(args, stores, customContext)\r\n            .then((resp) => {\r\n            if (currentActionOrd === cache.actionOrd[key]) {\r\n                if (postActionEnabled) {\r\n                    runPostActionHook(resp, args, stores, executionContext);\r\n                }\r\n                cache.results[key] = [true, true, resp, false, Date.now()];\r\n            }\r\n            return resp;\r\n        })\r\n            .catch((e) => {\r\n            console.error(e);\r\n            const result = {\r\n                payload: null,\r\n                errorPayload: null,\r\n                error: true,\r\n                tags: [EAsyncEndTags.THREW_ERROR],\r\n                message: e.message\r\n            };\r\n            if (currentActionOrd === cache.actionOrd[key]) {\r\n                if (postActionEnabled) {\r\n                    runPostActionHook(result, args, stores, executionContext);\r\n                }\r\n                cache.results[key] = [true, true, result, false, Date.now()];\r\n            }\r\n            return result;\r\n        })\r\n            .then((resp) => {\r\n            if (currentActionOrd === cache.actionOrd[key]) {\r\n                delete cache.actions[key];\r\n                if (!onServer) {\r\n                    notifyListeners(key);\r\n                }\r\n            }\r\n            return resp;\r\n        });\r\n    }\r\n    function checkKeyAndReturnResponse({ key, cache, initiate, ssr, args, stores, fromListener = false, postActionEnabled = true, cacheBreakEnabled = true, holdingResult, customContext, customCacheBreak, holdPrevious }) {\r\n        const cached = getCachedResult({\r\n            key,\r\n            cache,\r\n            args,\r\n            stores,\r\n            context: initiate ? EPostActionContext.BECKON_HIT_CACHE : EPostActionContext.WATCH_HIT_CACHE,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            fromListener,\r\n            customCacheBreak\r\n        });\r\n        if (cached.response) {\r\n            return cached.response;\r\n        }\r\n        if (!cache.actions.hasOwnProperty(key)) {\r\n            const currentActionOrd = actionOrdUpdate(cache, key);\r\n            if (initiate) {\r\n                if (shortCircuitHook !== undefined) {\r\n                    const shortCircuitResponse = shortCircuitHook({ args, stores });\r\n                    if (shortCircuitResponse !== false) {\r\n                        runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\r\n                        cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\r\n                        return cache.results[key];\r\n                    }\r\n                }\r\n                if (ssr || !onServer) {\r\n                    cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.BECKON_RUN, customContext);\r\n                }\r\n                if (!onServer) {\r\n                    cache.actions[key]();\r\n                    cache.results[key] = startedButUnfinishedResult;\r\n                }\r\n                else {\r\n                    return startedButUnfinishedResult;\r\n                }\r\n            }\r\n            else {\r\n                const resp = [\r\n                    false,\r\n                    false,\r\n                    {\r\n                        message: \"\",\r\n                        tags: [EAsyncEndTags.UNFINISHED],\r\n                        error: true,\r\n                        payload: null,\r\n                        errorPayload: null\r\n                    },\r\n                    false,\r\n                    -1\r\n                ];\r\n                if (!onServer) {\r\n                    cache.results[key] = resp;\r\n                }\r\n                if (holdPrevious) {\r\n                    if (holdingResult) {\r\n                        const response = [...holdingResult];\r\n                        response[3] = true;\r\n                        return response;\r\n                    }\r\n                    if (cached.previous != null) {\r\n                        const response = [...cached.previous];\r\n                        response[3] = true;\r\n                        return response;\r\n                    }\r\n                }\r\n                return resp;\r\n            }\r\n        }\r\n        if (holdPrevious) {\r\n            if (holdingResult) {\r\n                const response = [...holdingResult];\r\n                response[3] = true;\r\n                return response;\r\n            }\r\n            if (cached.previous != null) {\r\n                const response = [...cached.previous];\r\n                response[3] = true;\r\n                return response;\r\n            }\r\n        }\r\n        return startedButUnfinishedResult;\r\n    }\r\n    const read = (args = {}, { cacheBreakEnabled = true, postActionEnabled = true, key: customKey } = {}) => {\r\n        const key = _createKey(args, customKey);\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        let stores;\r\n        let customContext;\r\n        if (onServer || forceContext) {\r\n            const pullstateContext = useContext(PullstateContext);\r\n            stores = pullstateContext.stores;\r\n            customContext = pullstateContext.customContext;\r\n        }\r\n        else if (clientStores.loaded) {\r\n            stores = clientStores.stores;\r\n        }\r\n        else {\r\n            stores = storeErrorProxy;\r\n        }\r\n        const cached = getCachedResult({\r\n            key,\r\n            cache,\r\n            args,\r\n            stores,\r\n            context: EPostActionContext.READ_HIT_CACHE,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            fromListener: false\r\n        });\r\n        if (cached.response) {\r\n            if (!cached.response[2].error) {\r\n                return cached.response[2].payload;\r\n            }\r\n            else {\r\n                throw new PullstateAsyncError(cached.response[2].message, cached.response[2].tags);\r\n            }\r\n        }\r\n        if (!cache.actions.hasOwnProperty(key)) {\r\n            if (shortCircuitHook !== undefined) {\r\n                const shortCircuitResponse = shortCircuitHook({ args, stores });\r\n                if (shortCircuitResponse !== false) {\r\n                    runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\r\n                    cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\r\n                    if (!shortCircuitResponse.error) {\r\n                        return shortCircuitResponse.payload;\r\n                    }\r\n                    else {\r\n                        throw new PullstateAsyncError(shortCircuitResponse.message, shortCircuitResponse.tags);\r\n                    }\r\n                }\r\n            }\r\n            const currentActionOrd = actionOrdUpdate(cache, key);\r\n            cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.READ_RUN, customContext);\r\n            if (onServer) {\r\n                throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);\r\n            }\r\n            throw cache.actions[key]();\r\n        }\r\n        if (onServer) {\r\n            throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);\r\n        }\r\n        const watchOrd = watchIdOrd++;\r\n        throw new Promise((resolve) => {\r\n            cache.listeners[key][watchOrd] = () => {\r\n                delete cache.listeners[key][watchOrd];\r\n                resolve();\r\n            };\r\n        });\r\n    };\r\n    const useWatch = (args = {}, { initiate = false, ssr = true, postActionEnabled = false, cacheBreakEnabled = false, holdPrevious = false, dormant = false, key: customKey, cacheBreak: customCacheBreak } = {}) => {\r\n        const responseRef = useRef();\r\n        const prevKeyRef = useRef(\".\");\r\n        const key = dormant ? \".\" : _createKey(args, customKey);\r\n        let watchId = useRef(-1);\r\n        if (watchId.current === -1) {\r\n            watchId.current = watchIdOrd++;\r\n        }\r\n        if (!dormant) {\r\n            if (!shouldUpdate.hasOwnProperty(key)) {\r\n                shouldUpdate[key] = {\r\n                    [watchId.current]: true\r\n                };\r\n            }\r\n            else {\r\n                shouldUpdate[key][watchId.current] = true;\r\n            }\r\n        }\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        let stores;\r\n        let customContext;\r\n        if (onServer || forceContext) {\r\n            const pullstateContext = useContext(PullstateContext);\r\n            stores = pullstateContext.stores;\r\n            customContext = pullstateContext.customContext;\r\n        }\r\n        else if (clientStores.loaded) {\r\n            stores = clientStores.stores;\r\n        }\r\n        else {\r\n            stores = storeErrorProxy;\r\n        }\r\n        if (!onServer) {\r\n            const onAsyncStateChanged = () => {\r\n                if (shouldUpdate[key][watchId.current] && !isEqual(responseRef.current, cache.results[key])) {\r\n                    responseRef.current = checkKeyAndReturnResponse({\r\n                        key,\r\n                        cache,\r\n                        initiate,\r\n                        ssr,\r\n                        args,\r\n                        stores,\r\n                        fromListener: true,\r\n                        postActionEnabled,\r\n                        cacheBreakEnabled,\r\n                        holdingResult: undefined,\r\n                        customContext,\r\n                        holdPrevious\r\n                    });\r\n                    setWatchUpdate((prev) => {\r\n                        return prev + 1;\r\n                    });\r\n                }\r\n            };\r\n            if (!dormant) {\r\n                if (!cache.listeners.hasOwnProperty(key)) {\r\n                    cache.listeners[key] = {};\r\n                }\r\n                cache.listeners[key][watchId.current] = onAsyncStateChanged;\r\n                shouldUpdate[key][watchId.current] = true;\r\n            }\r\n            useEffect(() => {\r\n                if (!dormant) {\r\n                    cache.listeners[key][watchId.current] = onAsyncStateChanged;\r\n                    shouldUpdate[key][watchId.current] = true;\r\n                }\r\n                return () => {\r\n                    if (!dormant) {\r\n                        delete cache.listeners[key][watchId.current];\r\n                        shouldUpdate[key][watchId.current] = false;\r\n                    }\r\n                };\r\n            }, [key]);\r\n        }\r\n        const [_, setWatchUpdate] = useState(0);\r\n        if (dormant) {\r\n            responseRef.current =\r\n                holdPrevious && responseRef.current && responseRef.current[1]\r\n                    ? responseRef.current\r\n                    : [\r\n                        false,\r\n                        false,\r\n                        {\r\n                            message: \"\",\r\n                            tags: [EAsyncEndTags.DORMANT],\r\n                            error: true,\r\n                            payload: null\r\n                        },\r\n                        false,\r\n                        -1\r\n                    ];\r\n            prevKeyRef.current = \".\";\r\n        }\r\n        else if (prevKeyRef.current !== key) {\r\n            if (prevKeyRef.current !== null && shouldUpdate.hasOwnProperty(prevKeyRef.current)) {\r\n                delete cache.listeners[prevKeyRef.current][watchId.current];\r\n                shouldUpdate[prevKeyRef.current][watchId.current] = false;\r\n            }\r\n            prevKeyRef.current = key;\r\n            responseRef.current = checkKeyAndReturnResponse({\r\n                key,\r\n                cache,\r\n                initiate,\r\n                ssr,\r\n                args,\r\n                stores,\r\n                fromListener: false,\r\n                postActionEnabled,\r\n                cacheBreakEnabled,\r\n                holdingResult: holdPrevious && responseRef.current && responseRef.current[1] ? responseRef.current : undefined,\r\n                customContext,\r\n                customCacheBreak: typeof customCacheBreak === \"boolean\" ? () => customCacheBreak : customCacheBreak,\r\n                holdPrevious\r\n            });\r\n        }\r\n        return responseRef.current;\r\n    };\r\n    const useBeckon = (args = {}, { ssr = true, postActionEnabled = true, cacheBreakEnabled = true, holdPrevious = false, dormant = false, key } = {}) => {\r\n        const result = useWatch(args, {\r\n            initiate: true,\r\n            ssr,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            holdPrevious,\r\n            dormant,\r\n            key\r\n        });\r\n        return [result[1], result[2], result[3]];\r\n    };\r\n    const run = async (args = {}, inputs = {}) => {\r\n        const { treatAsUpdate = false, ignoreShortCircuit = false, respectCache = false, key: customKey, _asyncCache = clientAsyncCache, _stores = clientStores.loaded ? clientStores.stores : storeErrorProxy, _customContext, cacheBreak: customCacheBreak } = inputs;\r\n        const key = _createKey(args, customKey);\r\n        if (respectCache) {\r\n            const cached = getCachedResult({\r\n                key,\r\n                cache: _asyncCache,\r\n                args,\r\n                stores: _stores,\r\n                context: EPostActionContext.RUN_HIT_CACHE,\r\n                postActionEnabled: true,\r\n                cacheBreakEnabled: true,\r\n                fromListener: false,\r\n                customCacheBreak: typeof customCacheBreak === \"boolean\" ? () => customCacheBreak : customCacheBreak\r\n            });\r\n            if (cached.response && cached.response[0]) {\r\n                if (!cached.response[1]) {\r\n                    const watchOrd = watchIdOrd++;\r\n                    if (!_asyncCache.listeners.hasOwnProperty(key)) {\r\n                        _asyncCache.listeners[key] = {};\r\n                    }\r\n                    return new Promise((resolve) => {\r\n                        _asyncCache.listeners[key][watchOrd] = () => {\r\n                            const [, finished, resp] = _asyncCache.results[key];\r\n                            if (finished) {\r\n                                delete _asyncCache.listeners[key][watchOrd];\r\n                                resolve(resp);\r\n                            }\r\n                        };\r\n                    });\r\n                }\r\n                return cached.response[2];\r\n            }\r\n        }\r\n        if (!ignoreShortCircuit && shortCircuitHook !== undefined) {\r\n            const shortCircuitResponse = shortCircuitHook({ args, stores: _stores });\r\n            if (shortCircuitResponse !== false) {\r\n                _asyncCache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\r\n                runPostActionHook(shortCircuitResponse, args, _stores, EPostActionContext.SHORT_CIRCUIT);\r\n                notifyListeners(key);\r\n                return shortCircuitResponse;\r\n            }\r\n        }\r\n        const [, prevFinished, prevResp, prevUpdate, prevCacheTime] = _asyncCache.results[key] || [\r\n            false,\r\n            false,\r\n            {\r\n                error: true,\r\n                message: \"\",\r\n                payload: null,\r\n                tags: [EAsyncEndTags.UNFINISHED]\r\n            },\r\n            false,\r\n            -1\r\n        ];\r\n        if (prevFinished && treatAsUpdate) {\r\n            _asyncCache.results[key] = [true, true, prevResp, true, prevCacheTime];\r\n        }\r\n        else {\r\n            _asyncCache.results[key] = [\r\n                true,\r\n                false,\r\n                {\r\n                    error: true,\r\n                    message: \"\",\r\n                    payload: null,\r\n                    tags: [EAsyncEndTags.UNFINISHED]\r\n                },\r\n                false,\r\n                -1\r\n            ];\r\n        }\r\n        let currentActionOrd = actionOrdUpdate(_asyncCache, key);\r\n        _asyncCache.actions[key] = createInternalAction(key, _asyncCache, args, _stores, currentActionOrd, true, EPostActionContext.DIRECT_RUN, _customContext);\r\n        notifyListeners(key);\r\n        return _asyncCache.actions[key]();\r\n    };\r\n    const clearCache = (args = {}, { key: customKey, notify = true } = {}) => {\r\n        const key = _createKey(args, customKey);\r\n        clearActionCache(key, true, notify);\r\n    };\r\n    const clearAllCache = ({ notify = true } = {}) => {\r\n        for (const key of Object.keys(clientAsyncCache.actionOrd)) {\r\n            if (key.startsWith(`${ordinal}-`)) {\r\n                clearActionCache(key, true, notify);\r\n            }\r\n        }\r\n    };\r\n    const clearAllUnwatchedCache = ({ notify = true } = {}) => {\r\n        for (const key of Object.keys(shouldUpdate)) {\r\n            if (!Object.values(shouldUpdate[key]).some((su) => su)) {\r\n                delete shouldUpdate[key];\r\n                clearActionCache(key, false, notify);\r\n            }\r\n        }\r\n    };\r\n    const setCached = (args, result, options) => {\r\n        const { notify = true, key: customKey } = options || {};\r\n        const key = _createKey(args, customKey);\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        cache.results[key] = [true, true, result, false, Date.now()];\r\n        if (notify) {\r\n            notifyListeners(key);\r\n        }\r\n    };\r\n    const setCachedPayload = (args, payload, options) => {\r\n        return setCached(args, successResult(payload), options);\r\n    };\r\n    const updateCached = (args, updater, options) => {\r\n        const { notify = true, resetTimeCached = true, runPostActionHook: postAction = false, key: customKey } = options || {};\r\n        const key = _createKey(args, customKey);\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        if (cache.results.hasOwnProperty(key) && !cache.results[key][2].error) {\r\n            const currentCached = cache.results[key][2].payload;\r\n            const newResult = {\r\n                payload: produce$1(currentCached, (s) => updater(s, currentCached)),\r\n                error: false,\r\n                message: cache.results[key][2].message,\r\n                tags: cache.results[key][2].tags\r\n            };\r\n            if (postAction) {\r\n                runPostActionHook(newResult, args, clientStores.loaded ? clientStores.stores : storeErrorProxy, EPostActionContext.CACHE_UPDATE);\r\n            }\r\n            cache.results[key] = [\r\n                true,\r\n                true,\r\n                newResult,\r\n                cache.results[key][3],\r\n                resetTimeCached ? Date.now() : cache.results[key][4]\r\n            ];\r\n            if (notify) {\r\n                notifyListeners(key);\r\n            }\r\n        }\r\n    };\r\n    const getCached = (args = {}, options) => {\r\n        const { checkCacheBreak = false, key: customKey } = options || {};\r\n        const key = _createKey(args, customKey);\r\n        let cacheBreakable = false;\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        if (cache.results.hasOwnProperty(key)) {\r\n            if (checkCacheBreak && cacheBreakHook !== undefined) {\r\n                const stores = onServer\r\n                    ? useContext(PullstateContext).stores\r\n                    : clientStores.loaded\r\n                        ? clientStores.stores\r\n                        : storeErrorProxy;\r\n                if (cacheBreakHook({\r\n                    args,\r\n                    result: cache.results[key][2],\r\n                    stores,\r\n                    timeCached: cache.results[key][4]\r\n                })) {\r\n                    cacheBreakable = true;\r\n                }\r\n            }\r\n            const [started, finished, result, updating, timeCached] = cache.results[key];\r\n            return {\r\n                started,\r\n                finished,\r\n                result: result,\r\n                existed: true,\r\n                cacheBreakable,\r\n                updating,\r\n                timeCached\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                started: false,\r\n                finished: false,\r\n                result: {\r\n                    message: \"\",\r\n                    tags: [EAsyncEndTags.UNFINISHED],\r\n                    error: true,\r\n                    payload: null,\r\n                    errorPayload: null\r\n                },\r\n                updating: false,\r\n                existed: false,\r\n                cacheBreakable,\r\n                timeCached: -1\r\n            };\r\n        }\r\n    };\r\n    let delayedRunActionTimeout;\r\n    const delayedRun = (args = {}, { clearOldRun = true, delay, immediateIfCached = true, ...otherRunOptions }) => {\r\n        if (clearOldRun) {\r\n            clearTimeout(delayedRunActionTimeout);\r\n        }\r\n        if (immediateIfCached) {\r\n            const { finished, cacheBreakable } = getCached(args, { checkCacheBreak: true });\r\n            if (finished && !cacheBreakable) {\r\n                run(args, otherRunOptions);\r\n                return () => {\r\n                };\r\n            }\r\n        }\r\n        let ref = { cancelled: false };\r\n        delayedRunActionTimeout = setTimeout(() => {\r\n            if (!ref.cancelled) {\r\n                run(args, otherRunOptions);\r\n            }\r\n        }, delay);\r\n        return () => {\r\n            ref.cancelled = true;\r\n        };\r\n    };\r\n    const use = (args = {}, { initiate = true, ssr = true, postActionEnabled, cacheBreakEnabled, holdPrevious = false, dormant = false, key, onSuccess, cacheBreak: customCacheBreakHook } = {}) => {\r\n        if (postActionEnabled == null) {\r\n            postActionEnabled = initiate;\r\n        }\r\n        if (cacheBreakEnabled == null) {\r\n            cacheBreakEnabled = initiate;\r\n        }\r\n        const raw = useWatch(args, {\r\n            initiate,\r\n            ssr,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            holdPrevious,\r\n            dormant,\r\n            key,\r\n            cacheBreak: customCacheBreakHook\r\n        });\r\n        const [isStarted, isFinished, result, isUpdating] = raw;\r\n        const isSuccess = isFinished && !result.error;\r\n        const isFailure = isFinished && result.error;\r\n        if (onSuccess) {\r\n            useEffect(() => {\r\n                if (isSuccess && !dormant) {\r\n                    onSuccess(result.payload, args);\r\n                }\r\n            }, [isSuccess]);\r\n        }\r\n        const renderPayload = (func) => {\r\n            if (!result.error) {\r\n                return func(result.payload);\r\n            }\r\n            return React.Fragment;\r\n        };\r\n        return {\r\n            isStarted,\r\n            isFinished,\r\n            isUpdating,\r\n            isSuccess,\r\n            isFailure,\r\n            isLoading: isStarted && (!isFinished || isUpdating),\r\n            endTags: result.tags,\r\n            error: result.error,\r\n            payload: result.payload,\r\n            errorPayload: result.errorPayload,\r\n            renderPayload,\r\n            message: result.message,\r\n            raw,\r\n            execute: (runOptions) => run(args, runOptions),\r\n            clearCached: () => clearCache(args),\r\n            setCached: (response, options) => {\r\n                setCached(args, response, options);\r\n            },\r\n            setCachedPayload: (payload, options) => {\r\n                setCachedPayload(args, payload, options);\r\n            },\r\n            updateCached: (updater, options) => {\r\n                updateCached(args, updater, options);\r\n            }\r\n        };\r\n    };\r\n    const useDefer = (inputs = {}) => {\r\n        const [argState, setArgState] = useState(() => ({\r\n            key: inputs.key ? inputs.key : deferWaitingKey,\r\n            args: {}\r\n        }));\r\n        const initialResponse = use({}, {\r\n            ...inputs,\r\n            key: argState.key,\r\n            initiate: false\r\n        });\r\n        return {\r\n            ...initialResponse,\r\n            clearCached: () => {\r\n                clearCache({}, { key: argState.key });\r\n            },\r\n            unwatchExecuted: () => {\r\n                setArgState({ key: deferWaitingKey, args: {} });\r\n            },\r\n            setCached: (response, options = {}) => {\r\n                options.key = argState.key;\r\n                setCached({}, response, options);\r\n            },\r\n            setCachedPayload: (payload, options = {}) => {\r\n                options.key = argState.key;\r\n                setCachedPayload({}, payload, options);\r\n            },\r\n            updateCached: (updater, options = {}) => {\r\n                options.key = argState.key;\r\n                updateCached({}, updater, options);\r\n            },\r\n            execute: (args = {}, runOptions) => {\r\n                var _a;\r\n                const executionKey = (_a = inputs.key) !== null && _a !== void 0 ? _a : _createKey(args);\r\n                if (executionKey !== argState.key) {\r\n                    setArgState({ key: executionKey, args });\r\n                }\r\n                return run(args, {\r\n                    ...runOptions,\r\n                    key: executionKey,\r\n                    cacheBreak: inputs.cacheBreak\r\n                }).then(resp => {\r\n                    if (inputs.clearOnSuccess) {\r\n                        clearCache({}, { key: executionKey });\r\n                    }\r\n                    return resp;\r\n                });\r\n            },\r\n            args: argState.args,\r\n            key: argState.key\r\n        };\r\n    };\r\n    return {\r\n        use,\r\n        useDefer,\r\n        read,\r\n        useBeckon,\r\n        useWatch,\r\n        run,\r\n        delayedRun,\r\n        clearCache,\r\n        clearAllCache,\r\n        clearAllUnwatchedCache,\r\n        getCached,\r\n        setCached,\r\n        setCachedPayload,\r\n        updateCached\r\n    };\r\n}const PullstateContext = React.createContext(null);\r\nconst PullstateProvider = ({ instance, children }) => {\r\n    return React.createElement(PullstateContext.Provider, { value: instance }, children);\r\n};\r\nlet singleton = null;\r\nconst clientStores = {\r\n    internalClientStores: true,\r\n    loaded: false,\r\n    stores: {}\r\n};\r\nclass PullstateSingleton {\r\n    constructor(allStores, options = {}) {\r\n        this.options = {};\r\n        if (singleton !== null) {\r\n            console.error(`Pullstate: createPullstate() - Should not be creating the core Pullstate class more than once! In order to re-use pull state, you need to call instantiate() on your already created object.`);\r\n        }\r\n        singleton = this;\r\n        clientStores.stores = allStores;\r\n        clientStores.loaded = true;\r\n        this.options = options;\r\n    }\r\n    instantiate({ hydrateSnapshot, ssr = false, customContext } = {}) {\r\n        if (!ssr) {\r\n            const instantiated = new PullstateInstance(clientStores.stores, false, customContext);\r\n            if (hydrateSnapshot != null) {\r\n                instantiated.hydrateFromSnapshot(hydrateSnapshot);\r\n            }\r\n            instantiated.instantiateReactions();\r\n            return instantiated;\r\n        }\r\n        const newStores = {};\r\n        for (const storeName of Object.keys(clientStores.stores)) {\r\n            if (hydrateSnapshot == null) {\r\n                newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\r\n            }\r\n            else if (hydrateSnapshot.hasOwnProperty(storeName)) {\r\n                newStores[storeName] = new Store(hydrateSnapshot.allState[storeName]);\r\n            }\r\n            else {\r\n                newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\r\n                console.warn(`Pullstate (instantiate): store [${storeName}] didn't hydrate any state (data was non-existent on hydration object)`);\r\n            }\r\n            newStores[storeName]._setInternalOptions({\r\n                ssr,\r\n                reactionCreators: clientStores.stores[storeName]._getReactionCreators()\r\n            });\r\n        }\r\n        return new PullstateInstance(newStores, true, customContext);\r\n    }\r\n    useStores() {\r\n        return useStores();\r\n    }\r\n    useInstance() {\r\n        return useInstance();\r\n    }\r\n    createAsyncActionDirect(action, options = {}) {\r\n        return createAsyncActionDirect(action, options);\r\n    }\r\n    createAsyncAction(action, options = {}) {\r\n        var _a;\r\n        if (((_a = this.options.asyncActions) === null || _a === void 0 ? void 0 : _a.defaultCachingSeconds) && !options.cacheBreakHook) {\r\n            options.cacheBreakHook = (inputs) => inputs.timeCached < Date.now() - this.options.asyncActions.defaultCachingSeconds * 1000;\r\n        }\r\n        return createAsyncAction(action, options);\r\n    }\r\n}\r\nclass PullstateInstance {\r\n    constructor(allStores, ssr, customContext) {\r\n        this._ssr = false;\r\n        this._stores = {};\r\n        this._asyncCache = {\r\n            listeners: {},\r\n            results: {},\r\n            actions: {},\r\n            actionOrd: {}\r\n        };\r\n        this._stores = allStores;\r\n        this._ssr = ssr;\r\n        this._customContext = customContext;\r\n    }\r\n    getAllUnresolvedAsyncActions() {\r\n        return Object.keys(this._asyncCache.actions).map((key) => this._asyncCache.actions[key]());\r\n    }\r\n    instantiateReactions() {\r\n        for (const storeName of Object.keys(this._stores)) {\r\n            this._stores[storeName]._instantiateReactions();\r\n        }\r\n    }\r\n    getPullstateSnapshot() {\r\n        const allState = {};\r\n        for (const storeName of Object.keys(this._stores)) {\r\n            allState[storeName] = this._stores[storeName].getRawState();\r\n        }\r\n        return { allState, asyncResults: this._asyncCache.results, asyncActionOrd: this._asyncCache.actionOrd };\r\n    }\r\n    async resolveAsyncState() {\r\n        const promises = this.getAllUnresolvedAsyncActions();\r\n        await Promise.all(promises);\r\n    }\r\n    hasAsyncStateToResolve() {\r\n        return Object.keys(this._asyncCache.actions).length > 0;\r\n    }\r\n    get stores() {\r\n        return this._stores;\r\n    }\r\n    get customContext() {\r\n        return this._customContext;\r\n    }\r\n    async runAsyncAction(asyncAction, args = {}, runOptions = {}) {\r\n        if (this._ssr) {\r\n            runOptions._asyncCache = this._asyncCache;\r\n            runOptions._stores = this._stores;\r\n            runOptions._customContext = this._customContext;\r\n        }\r\n        return await asyncAction.run(args, runOptions);\r\n    }\r\n    hydrateFromSnapshot(snapshot) {\r\n        for (const storeName of Object.keys(this._stores)) {\r\n            if (snapshot.allState.hasOwnProperty(storeName)) {\r\n                this._stores[storeName]._updateStateWithoutReaction(snapshot.allState[storeName]);\r\n            }\r\n            else {\r\n                console.warn(`${storeName} didn't hydrate any state (data was non-existent on hydration object)`);\r\n            }\r\n        }\r\n        clientAsyncCache.results = snapshot.asyncResults || {};\r\n        clientAsyncCache.actionOrd = snapshot.asyncActionOrd || {};\r\n    }\r\n}\r\nfunction createPullstateCore(allStores = {}, options = {}) {\r\n    return new PullstateSingleton(allStores, options);\r\n}\r\nfunction useStores() {\r\n    return useContext(PullstateContext).stores;\r\n}\r\nfunction useInstance() {\r\n    return useContext(PullstateContext);\r\n}var EAsyncActionInjectType;\r\n(function (EAsyncActionInjectType) {\r\n    EAsyncActionInjectType[\"WATCH\"] = \"watch\";\r\n    EAsyncActionInjectType[\"BECKON\"] = \"beckon\";\r\n})(EAsyncActionInjectType || (EAsyncActionInjectType = {}));\r\nfunction InjectAsyncAction(props) {\r\n    if (props.type === EAsyncActionInjectType.BECKON) {\r\n        const response = props.action.useBeckon(props.args, props.options);\r\n        return props.children(response);\r\n    }\r\n    const response = props.action.useWatch(props.args, props.options);\r\n    return props.children(response);\r\n}function InjectStoreStateOpt({ store, paths, children }) {\r\n    const state = useStoreStateOpt(store, paths);\r\n    return children(state);\r\n}function registerInDevtools(stores, { namespace = \"\" } = {}) {\r\n    var _a;\r\n    const devToolsExtension = typeof window !== \"undefined\" ? (_a = window) === null || _a === void 0 ? void 0 : _a.__REDUX_DEVTOOLS_EXTENSION__ : undefined;\r\n    if (devToolsExtension) {\r\n        for (const key of Object.keys(stores)) {\r\n            const store = stores[key];\r\n            const devTools = devToolsExtension.connect({ name: `${namespace}${key}` });\r\n            devTools.init(store.getRawState());\r\n            let ignoreNext = false;\r\n            store.subscribe((s) => s, (watched) => {\r\n                if (ignoreNext) {\r\n                    ignoreNext = false;\r\n                    return;\r\n                }\r\n                devTools.send(\"Change\", watched);\r\n            });\r\n            devTools.subscribe((message) => {\r\n                if (message.type === \"DISPATCH\" && message.state) {\r\n                    ignoreNext = true;\r\n                    const parsed = JSON.parse(message.state);\r\n                    store.replace(parsed);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}const batchState = {};\r\nfunction setupBatch({ uiBatchFunction }) {\r\n    batchState.uiBatchFunction = uiBatchFunction;\r\n}\r\nfunction batch(runUpdates) {\r\n    if (globalClientState.batching) {\r\n        throw new Error(\"Pullstate: Can't enact two batch() update functions at the same time-\\n\" +\r\n            \"make sure you are not running a batch() inside of a batch() by mistake.\");\r\n    }\r\n    globalClientState.batching = true;\r\n    try {\r\n        runUpdates();\r\n    }\r\n    finally {\r\n        if (batchState.uiBatchFunction) {\r\n            batchState.uiBatchFunction(() => {\r\n                Object.values(globalClientState.flushStores).forEach(store => store.flushBatch(true));\r\n            });\r\n        }\r\n        else {\r\n            Object.values(globalClientState.flushStores).forEach(store => store.flushBatch(true));\r\n        }\r\n        globalClientState.flushStores = {};\r\n        globalClientState.batching = false;\r\n    }\r\n}export{EAsyncActionInjectType,EAsyncEndTags,EPostActionContext,InjectAsyncAction,InjectStoreState,InjectStoreStateOpt,PullstateContext,PullstateProvider,Store,batch,createAsyncAction,createAsyncActionDirect,createPullstateCore,errorResult,registerInDevtools,setupBatch,successResult,update,useInstance,useLocalStore,useStoreState,useStoreStateOpt,useStores};"]},"metadata":{},"sourceType":"module"}